/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <cstrike>
#include <clientprefs>
#include <CodD0_engine_consts>
#include <CodD0_clans>
#include <MEd0_engine>

#define IsPlayer(%1) (1<=%1<=MAXPLAYERS)

int g_levelExp[] =  {
	0,
	75,300,675,1200,1875,2700,3675,4800,6075,7500,
	9075,10800,12675,14700,16875,19200,21675,24300,27075,30000,
	33075,36300,39675,43200,46875,50700,54675,58800,63075,67500,
	72075,76800,81675,86700,91875,97200,102675,108300,114075,120000,
	126075,132300,138675,145200,151875,158700,165675,172800,180075,187500,
	195075,202800,210675,218700,226875,235200,243675,252300,261075,270000,
	279075,288300,297675,307200,316875,326700,336675,346800,357075,367500,
	378075,388800,399675,410700,421875,433200,444675,456300,468075,480000,
	492075,504300,516675,529200,541875,554700,567675,580800,594075,607500,
	621075,634800,648675,662700,676875,691200,705675,720300,735075,750000,
	765075,780125,800000,820125,840500,861125,882000,903125,924500,946125,
	968000,990125,1012500,1035125,1058000,1081125,1104500,1128125,1152000,1176125,
	1200500,1225125,1250000,1275125,1300500,1326125,1352000,1378125,1404500,1431125,
	1458000,1485125,1512500,1540125,1568000,1596125,1624500,1653125,1682000,1711125,
	1740500,1770125,1800000,1830125,1860500,1891125,1922000,1953125,1984500,2016125,
	2048000,2080125,2112500,2145125,2178000,2211125,2244500,2278125,2312000,2346125,
	2380500,2415125,2450000,2485125,2520500,2556125,2592000,2628125,2664500,2701125,
	2738000,2775125,2812500,2850125,2888000,2926125,2964500,3003125,3042000,3081125,
	3120500,3160125,3200000,3240125,3280500,3321125,3362000,3403125,3444500,3486125,
	3528000,3570125,3612500,3655125,3698000,3741125,3784500,3828125,3872000,3916125,
	3960500
}

Handle g_fwClassChanged, g_fwClassChangedPost, g_fwPerkChanged, g_fwPerkChangedPost, g_fwPerkUsed, g_fwClassSkillUsed;


ConVar g_cvExpForKill, g_cvExpForKillByHS, g_cvExpForAssist,
	g_cvExpForRevenge, g_cvExpLevelDifference, g_cvExpForBombPlanting, 
	g_cvExpForBombDefusing, g_cvExpForHostage, g_cvExpForWinningRound, 
	g_cvCoinsForKill, g_cvCoinsForKillByHS, g_cvCoinsForAssist, 
	g_cvCoinsForRevenge, g_cvCoinsForBombPlanting, g_cvCoinsForBombDefusing, 
	g_cvCoinsForHostage, g_cvCoinsForWinningRound, g_cvPrefix, 
	g_cvFreeLevelMultiplier;

bool g_canTakeWeapons[MAXPLAYERS + 1], g_soundEffects[MAXPLAYERS+1];
int g_hudType[MAXPLAYERS + 1];

//Classes
int g_classesNum, g_perksNum;
bool g_isClassAvailable[MAX_CLASSESNUM + 1];
char g_className[MAX_CLASSESNUM + 1][MAX_CLASSNAME_LENGTH + 1], g_classDesc[MAX_CLASSESNUM + 1][MAX_CLASSDESC_LENGTH + 1];
CSWeaponID g_classWeapon[MAX_CLASSESNUM + 1][MAX_CLASSWEAPONSNUM + 1];
int g_classWeaponsNum[MAX_CLASSESNUM + 1];
//char g_szBronKlasy[MAX_CLASSESNUM + 1][MAX_CLASSWEAPONSNUM + 1][MAX_BRON + 1], g_iIloscBroniKlasy[MAX_CLASSESNUM + 1];
int g_classStats[MAX_CLASSESNUM + 1][5];
int g_sortedClassesOrder[MAX_CLASSESNUM + 1];
//int g_iAwansKlasy[MAX_CLASSESNUM + 1], g_iWymaganyPoziomDoAwansuKlasy[MAX_CLASSESNUM + 1], bool:g_bKlasaJestAwansem[MAX_CLASSESNUM + 1];

//Perks
char g_perkName[MAX_PERKSNUM + 1][MAX_PERKNAME_LENGTH + 1], g_perkDesc[MAX_PERKSNUM + 1][MAX_PERKDESC_LENGTH + 1];
int g_perkValue[MAX_PERKSNUM + 1][2];
int g_sortedPerksOrder[MAX_PERKSNUM + 1];

//Stats points
int g_statsPointsToAssign[] = { 1, 5, 10, 25, 50 };

bool g_allPluginsLoaded;

int g_plrStatsPoints[MAXPLAYERS + 1][5], g_plrBonusStatsPoints[MAXPLAYERS + 1][5], g_plrUsableIntelligence[MAXPLAYERS + 1];
int g_plrClass[MAXPLAYERS + 1], g_plrLastSelectedClass[MAXPLAYERS + 1], g_plrNewSelectedClass[MAXPLAYERS + 1];
int g_plrLevel[MAXPLAYERS + 1], g_plrClassLevel[MAXPLAYERS + 1][MAX_CLASSESNUM + 1], g_plrExp[MAXPLAYERS + 1];
int g_plrPerk[MAXPLAYERS + 1], g_plrPerkValue[MAXPLAYERS + 1];
int g_plrCoins[MAXPLAYERS + 1], g_plrStatsPointsToAssignID[MAXPLAYERS + 1];
//char g_szBonusowaBronGracza[MAXPLAYERS + 1][MAX_BONUSWEAPONSNUM + 1][MAX_BRON + 1], g_iIloscBonusowychBroniGracza[MAXPLAYERS + 1];
CSWeaponID g_plrBonusWeapon[MAXPLAYERS + 1][MAX_BONUSWEAPONSNUM + 1];
int g_plrBonusWeaponsNum[MAXPLAYERS + 1];
float g_plrNextClassSkillUsage[MAXPLAYERS + 1], g_plrNextPerkUsage[MAXPLAYERS + 1];
Handle g_plrTimerNextClassSkillUsage[MAXPLAYERS + 1], g_plrTimerNextPerkUsage[MAXPLAYERS + 1];
Handle g_plrTimerUseClassSkill[MAXPLAYERS + 1];
bool g_isPlayerDataLoading[MAXPLAYERS + 1], g_isPlayerClassDataLoading[MAXPLAYERS + 1];

int g_plrLastExploId[MAXPLAYERS + 1];
int g_lastPlrButtons[MAXPLAYERS + 1];
float g_lastTimePlrOpenedDoor[MAXPLAYERS + 1];

//top15 
char g_top15_name[15][64], g_top15_class[15][MAX_CLASSNAME_LENGTH]; //sprawdz nickname
int g_top15_level[15], g_top15_exp[15];

Handle g_sqlConn, g_hudSync, g_cookieSoundEffect, g_cookieHudMode;
bool g_freezeTime;
char g_prefix[32];
int g_accountOffset;

public Plugin myinfo = {
	name = "Call Of Duty Mod", 
	author = "d0naciak", 
	description = "Call Of Duty Mod from CS 1.6", 
	version = "1.0.0", 
	url = "d0naciak.pl"
}

public void OnPluginStart() {

	g_accountOffset = FindSendPropInfo("CCSPlayer", "m_iAccount");
	
	if (g_accountOffset == -1) {
		SetFailState("Can't find m_iAccount offset");
		return;
	}

	HookEvent("round_start", ev_RoundStart_Post);
	HookEvent("round_freeze_end", ev_RoundFreezeEnd_Post);
	HookEvent("player_death", ev_PlayerDeath_Post);
	HookEvent("bomb_planted", ev_BombPlanted_Post);
	HookEvent("bomb_defused", ev_BombDefused_Post);
	HookEvent("hostage_rescued", ev_HostRescued_Post);
	HookEvent("round_end", ev_RoundEnd_Post);
	
	AddNormalSoundHook(ev_Sound);
	RegConsoleCmd("sm_useitem", cmd_UsePerk);
	RegConsoleCmd("sm_useperk", cmd_UsePerk);
	RegConsoleCmd("Use_Perk", cmd_UsePerk);
	RegConsoleCmd("sm_useskill", cmd_UseClassSkill);
	RegConsoleCmd("Use_Class", cmd_UseClassSkill);
	RegConsoleCmd("sm_klasa", cmd_SelectClass);
	RegConsoleCmd("sm_k", cmd_SelectClass);
	RegConsoleCmd("sm_klasy", cmd_ClassesDescs);
	RegConsoleCmd("sm_perk", cmd_PerkDesc);
	RegConsoleCmd("sm_p", cmd_PerkDesc);
	RegConsoleCmd("sm_perki", cmd_PerksDescs);
	//RegConsoleCmd("sm_drop", cmd_DropPerk);
	RegConsoleCmd("sm_d", cmd_DropPerk);
	RegConsoleCmd("sm_staty", cmd_AssignStatsPoints);
	RegConsoleCmd("sm_stats", cmd_AssignStatsPoints);
	RegConsoleCmd("sm_resetstat", cmd_ResetStatsPoints);
	RegConsoleCmd("sm_resetstats", cmd_ResetStatsPoints);
	RegConsoleCmd("sm_bindy", cmd_Binds);
	RegConsoleCmd("sm_binds", cmd_Binds);
	RegConsoleCmd("sm_top15lvl", cmd_Top15);
	RegConsoleCmd("sm_ranklvl", cmd_Rank);
	RegConsoleCmd("drop", cmd_UsePerk);

	g_cookieSoundEffect = RegClientCookie("codd0_soundeffects", "COD: Dźwięk LEVEL UP", CookieAccess_Private);
	g_cookieHudMode = RegClientCookie("codd0_hudmode", "COD: Tryb HUD", CookieAccess_Private);
	SetCookieMenuItem(cookie_LevelUpSound, 0, "COD: Dźwięk LEVEL UP");
	SetCookieMenuItem(cookie_HUDMode, 0, "COD: Tryb HUD");

	RegAdminCmd("cod_givexp", cmd_GiveExp, ADMFLAG_ROOT, "gives experience to player's class");
	RegAdminCmd("cod_setxp", cmd_SetExp, ADMFLAG_ROOT, "sets experience to player's class");
	RegAdminCmd("cod_givelvl", cmd_GiveLevel, ADMFLAG_ROOT, "gives level to player's class");
	RegAdminCmd("cod_setlvl", cmd_SetLevel, ADMFLAG_ROOT, "sets level to player's class");
	RegAdminCmd("cod_givecoins", cmd_GiveCoins, ADMFLAG_ROOT, "gives coins to player");
	RegAdminCmd("cod_setcoins", cmd_SetCoins, ADMFLAG_ROOT, "sets coins to player");
	RegAdminCmd("cod_setperk", cmd_SetPerk, ADMFLAG_ROOT, "sets perk to player");
	//RegConsoleCmd("jointeam", cmd_WyborDruzyny);
	
	g_cvExpForKill = CreateConVar("cod_killxp", "200", "Experience for kill");
	g_cvExpForKillByHS = CreateConVar("cod_hsxp", "100", "Additional experience for headshot");
	g_cvExpForAssist = CreateConVar("cod_assistxp", "60", "Experience for assist");
	g_cvExpForRevenge = CreateConVar("cod_revengexp", "100", "Additional experience for revenge");
	g_cvExpLevelDifference = CreateConVar("cod_leveldifferencexp", "1.0", "Additional experience multiplier for level difference (difference * cvar)");
	g_cvExpForBombPlanting = CreateConVar("cod_plantbombxp", "400", "Experience for planting bomb");
	g_cvExpForBombDefusing = CreateConVar("cod_defusebombxp", "400", "Experience for defusing bomb");
	g_cvExpForHostage = CreateConVar("cod_rescuehostagexp", "100", "Experience for rescueing hostage");
	g_cvExpForWinningRound = CreateConVar("cod_winroundxp", "50", "Experience for winning round");

	g_cvCoinsForKill = CreateConVar("cod_killcoins", "3", "Coins for kill");
	g_cvCoinsForKillByHS = CreateConVar("cod_hscoins", "1", "Additional coins for headshot");
	g_cvCoinsForAssist = CreateConVar("cod_assistcoins", "1", "Coins for assist");
	g_cvCoinsForRevenge = CreateConVar("cod_revengecoins", "3", "Additional coins for revenge");
	g_cvCoinsForBombPlanting = CreateConVar("cod_plantbombcoins", "4", "Coins for planting bomb");
	g_cvCoinsForBombDefusing = CreateConVar("cod_defusebombcoins", "4", "Coins for defusing bomb");
	g_cvCoinsForHostage = CreateConVar("cod_rescuehostagcoins", "4", "Coins for rescueing hostage");
	g_cvCoinsForWinningRound = CreateConVar("cod_winroundcoins", "1", "Coins for winning round");

	g_cvPrefix = CreateConVar("cod_prefix", "[COD:MW]", "Prefix in chat messages");
	g_cvFreeLevelMultiplier = CreateConVar("cod_freelevelmultiplier", "0.1", "Mulitplier * max. level = free level. Set to 0 to disable free lvl");

	g_cvPrefix.AddChangeHook(ConVar_OnPrefixChange);

	AutoExecConfig(true, "codmod");

	g_fwClassChanged = CreateGlobalForward("CodD0_ClassChanged", ET_Event, Param_Cell, Param_Cell);
	g_fwClassChangedPost = CreateGlobalForward("CodD0_ClassChanged_Post", ET_Ignore, Param_Cell, Param_Cell);
	g_fwPerkChanged = CreateGlobalForward("CodD0_PerkChanged", ET_Event, Param_Cell, Param_Cell, Param_Cell);
	g_fwPerkChangedPost = CreateGlobalForward("CodD0_PerkChanged_Post", ET_Ignore, Param_Cell, Param_Cell, Param_Cell);
	g_fwClassSkillUsed = CreateGlobalForward("CodD0_ClassSkillUsed", ET_Ignore, Param_Cell, Param_Cell);
	g_fwPerkUsed = CreateGlobalForward("CodD0_PerkUsed", ET_Ignore, Param_Cell, Param_Cell);
	
	strcopy(g_className[0], MAX_CLASSNAME_LENGTH, "Brak");
	strcopy(g_perkName[0], MAX_PERKNAME_LENGTH, "Brak");
	
	char error[512];
	g_sqlConn = SQL_Connect("CodMod", true, error, sizeof(error));
	if (g_sqlConn == null) {
		SetFailState("CodMod d0 SQL: Error while connecting to DB: %s", error);
	} else {
		SQL_LockDatabase(g_sqlConn);

		char query[][] = {
				"CREATE TABLE IF NOT EXISTS codd0_players\
				( \
					playerID int NOT NULL AUTO_INCREMENT, \
					steamID varchar(64) NOT NULL, \
					name varchar(64) NOT NULL, \
					coins int NOT NULL DEFAULT 0,  \
					PRIMARY KEY (playerID) \
				) ENGINE = InnoDB DEFAULT CHARSET = utf8;",

				"CREATE TABLE IF NOT EXISTS codd0_classes \
				( \
					classID int NOT NULL AUTO_INCREMENT, \
					name varchar(32) NOT NULL, \
					PRIMARY KEY (classID), \
					UNIQUE (name) \
				) ENGINE = InnoDB DEFAULT CHARSET = utf8;",

				"CREATE TABLE IF NOT EXISTS codd0_experience \
				( \
					playerClassID int NOT NULL AUTO_INCREMENT, \
					playerID int NOT NULL, \
					classID int NOT NULL, \
					level int UNSIGNED NOT NULL DEFAULT 1, \
					experience int UNSIGNED NOT NULL DEFAULT 0, \
					statHealth int UNSIGNED NOT NULL DEFAULT 0, \
					statIntelligence int UNSIGNED NOT NULL DEFAULT 0, \
					statStamina int UNSIGNED NOT NULL DEFAULT 0, \
					statTrim int UNSIGNED NOT NULL DEFAULT 0, \
					PRIMARY KEY (playerClassID) \
				) ENGINE = InnoDB DEFAULT CHARSET = utf8;"
			}
		if(SQL_FastQuery(g_sqlConn, query[0]) && SQL_FastQuery(g_sqlConn, query[1]) && SQL_FastQuery(g_sqlConn, query[2])) {
			PrintToServer("CodMod d0 SQL: Tabels has been created");
		} else {
			if(SQL_GetError(g_sqlConn, error, sizeof(error))) {
				PrintToServer("CodMod d0 SQL: Error while creating tables: %s", error);
			}
		}

		SQL_UnlockDatabase(g_sqlConn);
	}

	g_hudSync = CreateHudSynchronizer();

	for(new i = 1; i <= MaxClients; i++) {
		if(IsClientAuthorized(i)) {
			for (new j = 1; j <= g_classesNum; j++) {
				g_plrClassLevel[i][j] = 1;
			}

			g_plrLevel[i] = 1;

			ReadPlayerData(i);

			if(AreClientCookiesCached(i)) {
				OnClientCookiesCached(i);
			}
		}

		if(IsClientInGame(i)) {
			OnClientPutInServer(i);
			cmd_SelectClass(i, 0);
		}
	}
}

public void OnPluginEnd() {
	for(int i = 1; i <= MaxClients; i++) {
		if(!IsClientInGame(i)) {
			continue;
		}

		if(g_plrClass[i]) {
			SaveClientClassData(i, g_plrClass[i]);
			SetClientClass(i, 0);
		}

		SaveClientData(i, true);
	}
}

public void OnAllPluginsLoaded() {
	char query[256], escapedName[MAX_CLASSNAME_LENGTH*2+1];

	for(new i = 1; i <= g_classesNum; i++) {
		SQL_EscapeString(g_sqlConn, g_className[i], escapedName, MAX_CLASSNAME_LENGTH*2);
		Format(query, sizeof(query), "SELECT classID FROM codd0_classes WHERE name='%s'", escapedName);

		SQL_TQuery(g_sqlConn, IsClassInDB_Handler, query, i);
	}

	SortClasses();
	SortPerks();
	g_allPluginsLoaded = true;
}

public void OnMapStart() {
	AddFileToDownloadsTable("sound/CodMod_d0naciak/engine/level_up.mp3");

	PrecacheSound("weapons/hegrenade/explode5.wav");
	PrecacheSound("items/battery_pickup.wav");

	for (int client = 1; client <= MaxClients; client++) {
		g_plrUsableIntelligence[client] = 0;

		for (int i = 0; i <= 4; i++) {
			g_plrStatsPoints[client][i] = 0;
		}
	}
}

public void OnMapEnd() {
	for(new i = 1; i <= MaxClients; i++) {
		if(g_plrPerk[i]) {
			SetClientPerk(i, 0);
		}

		if(g_plrClass[i]) {
			SetClientClass(i, 0);
		}
	}
}

public void OnConfigsExecuted() {
	g_cvPrefix.GetString(g_prefix, sizeof(g_prefix));
}

public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int errorLen) {
	RegPluginLibrary("codd0_engine");

	CreateNative("CodD0_RegisterClass", nat_RegisterClass);
	CreateNative("CodD0_UnregisterClass", nat_UnregisterClass);
	CreateNative("CodD0_RegisterPerk", nat_RegisterPerk);
	CreateNative("CodD0_UnregisterPerk", nat_UnregisterPerk);
	
	CreateNative("CodD0_GetClassesNum", nat_GetClassesNum);
	CreateNative("CodD0_GetPerksNum", nat_GetPerksNum);
	CreateNative("CodD0_GetClassID", nat_GetClassID);
	CreateNative("CodD0_GetPerkID", nat_GetPerkID);
	CreateNative("CodD0_GetClassName", nat_GetClassName);
	CreateNative("CodD0_GetClassDesc", nat_GetClassDesc);
	CreateNative("CodD0_GetClassWeapons", nat_GetClassWeapons);
	CreateNative("CodD0_GetClassStatsPoints", nat_GetClassStatsPoints);
	CreateNative("CodD0_GetPerkName", nat_GetPerkName);
	CreateNative("CodD0_GetPerkDesc", nat_GetPerkDesc);
	CreateNative("CodD0_GetPerkMaxValue", nat_GetPerkMaxValue);
	CreateNative("CodD0_GetPerkMinValue", nat_GetPerkMinValue);
	CreateNative("CodD0_GetLevelExp", nat_GetLevelExp);
	
	CreateNative("CodD0_GetClientExp", nat_GetClientExp);
	CreateNative("CodD0_GetClientLevel", nat_GetClientLevel);
	CreateNative("CodD0_GetClientClass", nat_GetClientClass);
	CreateNative("CodD0_GetClientPerk", nat_GetClientPerk);
	CreateNative("CodD0_GetClientPerkValue", nat_GetClientPerkValue);
	CreateNative("CodD0_GetClientStatsPoints", nat_GetClientStatsPoints);
	CreateNative("CodD0_GetClientBonusStatsPoints", nat_GetClientBonusStatsPoints);
	CreateNative("CodD0_GetClientCoins", nat_GetClientCoins);
	CreateNative("CodD0_GetClientUsableIntelligence", nat_GetClientUsableIntelligence);
	
	CreateNative("CodD0_SetClientExp", nat_SetClientExp);
	CreateNative("CodD0_SetClientLevel", nat_SetClientLevel);
	CreateNative("CodD0_SetClientClass", nat_SetClientClass);
	CreateNative("CodD0_SetClientPerk", nat_SetClientPerk);
	CreateNative("CodD0_SetClientStatsPoints", nat_SetClientStatsPoints);
	CreateNative("CodD0_SetClientBonusStatsPoints", nat_SetClientBonusStatsPoints);
	CreateNative("CodD0_SetClientCoins", nat_SetClientCoins);
	CreateNative("CodD0_GiveClientWeapon", nat_GiveClientWeapon);
	CreateNative("CodD0_TakeClientWeapon", nat_TakeClientWeapon);
	CreateNative("CodD0_InflictDamage", nat_InflictDamage);
	CreateNative("CodD0_MakeExplosion", nat_MakeExplosion);

	CreateNative("CodD0_ClientClassSkillGotReady", nat_ClientClassSkillGotReady);
	CreateNative("CodD0_ClientPerkGotReady", nat_ClientPerkGotReady);
	
	return APLRes_Success;
}

public void ConVar_OnPrefixChange (ConVar conVar, const char[] oldValue, const char[] newValue) {
	strcopy(g_prefix, sizeof(g_prefix), newValue);
}

public void OnEntityCreated(int entity, const char[] classname) {
	if(StrEqual(classname, "prop_door_rotating")) {
		SDKHook(entity, SDKHook_UsePost, ev_UseDoor_Post)
	}
}

public void ev_UseDoor_Post(int entity, int activator, int caller, UseType type, float value) {
	if(activator < 1 || activator > MAXPLAYERS) {
		return;
	}

	g_lastTimePlrOpenedDoor[activator] = GetGameTime();
}

public void OnClientAuthorized(int client) {
	for (int i = 1; i <= g_classesNum; i++) {
		g_plrClassLevel[client][i] = 1;
	}
	
	g_plrLevel[client] = 1;
	g_plrExp[client] = 0;
	g_plrCoins[client] = 0;
	g_plrUsableIntelligence[client] = 0;

	for (int i = 0; i <= 4; i++) {
		g_plrStatsPoints[client][i] = 0;
	}

	g_isPlayerDataLoading[client] = false;
	g_isPlayerClassDataLoading[client] = false;
	
	ReadPlayerData(client);
}

public void OnClientPutInServer(int client) {
	SDKHook(client, SDKHook_OnTakeDamage, ev_OnTakeDamage);
	SDKHook(client, SDKHook_WeaponEquipPost, ev_WeaponEquip_Post);
	SDKHook(client, SDKHook_SpawnPost, ev_Spawn_Post);
	
	CreateTimer(1.5, timer_HUD, GetClientSerial(client), TIMER_REPEAT);
}

public void OnClientDisconnect(int client) {
	SDKUnhook(client, SDKHook_OnTakeDamage, ev_OnTakeDamage);
	SDKUnhook(client, SDKHook_WeaponEquipPost, ev_WeaponEquip_Post);
	SDKUnhook(client, SDKHook_SpawnPost, ev_Spawn_Post);
	
	SetClientClass(client, 0);
	SetClientPerk(client, 0);
	g_plrBonusWeaponsNum[client] = 0;
	g_plrStatsPointsToAssignID[client] = 0;
	
	for (int i = 1; i <= 4; i++) {
		g_plrBonusStatsPoints[client][i] = 0;
	}
	
	g_plrNextClassSkillUsage[client] = 0.0;
	g_plrNextPerkUsage[client] = 0.0;
	g_lastPlrButtons[client] = 0;
	g_lastTimePlrOpenedDoor[client] = 0.0;

	if(g_plrTimerNextClassSkillUsage[client] != null) {
		KillTimer(g_plrTimerNextClassSkillUsage[client]);
		g_plrTimerNextClassSkillUsage[client] = null;
	}

	if(g_plrTimerNextPerkUsage[client] != null) {
		KillTimer(g_plrTimerNextPerkUsage[client]);
		g_plrTimerNextPerkUsage[client] = null;
	}

	if(g_plrTimerUseClassSkill[client] != null) {
		KillTimer(g_plrTimerUseClassSkill[client]);
		g_plrTimerUseClassSkill[client] = null;
	}

	g_canTakeWeapons[client] = false;
	g_plrLastExploId[client] = 0;

	SaveClientData(client);
	g_isPlayerDataLoading[client] = true;
}

public Action OnPlayerRunCmd(int client, int &buttons, int &impulse, float vel[3], float angles[3], int &weapon, int &subtype, int &cmdnum, int &tickcount, int &seed, int mouse[2]) {
	if(!IsClientInGame(client) || !IsPlayerAlive(client)) {
		return Plugin_Continue;
	}

	int playerBombEntity = GetPlayerWeaponSlot(client, CS_SLOT_C4);

	if((playerBombEntity <= 0 || playerBombEntity != GetEntPropEnt(client, Prop_Data, "m_hActiveWeapon")) && buttons & IN_USE && !(g_lastPlrButtons[client] & IN_USE)) {
		int target = GetClientAimTarget(client, false);
		bool timer = true;

		if(target > 0) {
			char classname[64];
			float pos[2][3];

			GetEntPropString(target, Prop_Data, "m_iClassname", classname, sizeof(classname));
			GetEntPropVector(client, Prop_Send, "m_vecOrigin", pos[0]);
			GetEntPropVector(target, Prop_Send, "m_vecOrigin", pos[1]);

			/*if(StrEqual(classname, "prop_door_rotating")) {
				if(GetVectorDistance(pos[0], pos[1]) < 94.0) {
					timer = false;
				}
			} else */
			if(StrEqual(classname, "hostage_entity")) {
				if(GetVectorDistance(pos[0], pos[1]) < 60.0) {
					timer = false;
				}
			} else if(StrEqual(classname, "player")) {
				if(GetVectorDistance(pos[0], pos[1]) < 94.0 && playerBombEntity > 0 && GetClientTeam(client) == GetClientTeam(target)) {
					timer = false;
					//PrintToChatAll("BLOCK BECAUSE PLAYER")
				}
			}
		}

		if(timer) {
			g_plrTimerUseClassSkill[client] = CreateTimer(0.01, timer_UseClassSkill, client);
		}
	}

	g_lastPlrButtons[client] = buttons;
	return Plugin_Continue;
}

public Action timer_UseClassSkill(Handle timer, any client) {
	if(IsClientInGame(client) && IsPlayerAlive(client) && !GetEntProp(client, Prop_Send, "m_bIsDefusing") && (GetGameTime()-g_lastTimePlrOpenedDoor[client]) > 0.2) {
		cmd_UseClassSkill(client, 0);
	}

	g_plrTimerUseClassSkill[client] = null;
	return Plugin_Continue;
}

public Action CS_OnBuyCommand(int client, const char[] weaponName) {
	return Plugin_Handled;
}

public Action ev_OnTakeDamage(int victim, int &attacker, int &ent, float &damage, int &damageType, int &weapon, float damageForce[3], float damagePos[3], int damageCustom) {
	if (attacker <= 0 || attacker > MAXPLAYERS || !IsClientInGame(attacker) || !IsPlayerAlive(attacker)) {
		return Plugin_Continue;
	}

	if (g_plrLastExploId[victim] == ent) {
		damage = 0.0;
		damageType = 0;
		g_plrLastExploId[victim] = 0;
		return Plugin_Changed;
	}

	return Plugin_Continue;
}

public void ev_WeaponEquip_Post(int client, int weaponEnt) {
	if (!IsClientInGame(client) || g_canTakeWeapons[client]) {
		return;
	}

	CSWeaponID weaponID = GetWeaponID(weaponEnt);
	
	if (weaponID == CSWeapon_KNIFE || weaponID == CSWeapon_C4) {
		return;
	}

	int plrClass = g_plrClass[client];

	for (int i = 0; i < g_classWeaponsNum[plrClass]; i++) {
		if(weaponID == g_classWeapon[plrClass][i]) {
			return;
		}
	}
	
	for (int i = 0; i < g_plrBonusWeaponsNum[client]; i++) {
		if(weaponID == g_plrBonusWeapon[client][i]) {
			return;
		}
	}
	
	RemovePlayerItem(client, weaponEnt);
	AcceptEntityInput(weaponEnt, "kill");
}

public void ev_Spawn_Post(int client) {
	if(!IsClientInGame(client) || !IsPlayerAlive(client)) {
		return;
	}

	int plrClass = g_plrClass[client];

	if (g_plrNewSelectedClass[client] != plrClass) {
		SetClientClass(client, g_plrNewSelectedClass[client]);
	}

	UpdateClientWeapons(client);
	UpdateClientStatsBonuses(client);

	CreateTimer(0.15, timer_SpawnDelay, GetClientUserId(client));
}


public Action timer_SpawnDelay(Handle timer, any userID) {
	int client = GetClientOfUserId(userID);

	if(!client) {
		return Plugin_Continue;
	}

	if(!g_isPlayerDataLoading[client]) {
		SetEntData(client, g_accountOffset, g_plrCoins[client], 4, true);
	}

	if (GameRules_GetProp("m_bWarmupPeriod") == 1) {
		SelectPrimaryWeapon(client);
		return Plugin_Continue;
	}

	if(!g_plrClass[client]) {
		cmd_SelectClass(client, 0);
	}
	
	if (g_plrStatsPoints[client][TOASSIGN_PTS] > 0 && !g_isPlayerClassDataLoading[client]) {
		cmd_AssignStatsPoints(client, 0);
	}

	return Plugin_Continue;
}

void SelectPrimaryWeapon(int client) {
	Menu menu = new Menu(SelectPrimaryWeapon_Handler, MENU_ACTIONS_ALL);

	menu.SetTitle("➫ Wybierz karabin: ");

	menu.AddItem("weapon_ak47", "AK-47");
	menu.AddItem("weapon_m4a1", "M4A4");
	menu.AddItem("weapon_m4a1_silencer", "M4A1-S");
	menu.AddItem("weapon_awp", "AWP");
	menu.AddItem("weapon_ssg08", "SCOUT");
	menu.AddItem("weapon_famas", "FAMAS");
	menu.AddItem("weapon_negev", "NEGEV");
	menu.AddItem("weapon_mp5sd", "MP5-SD");
	menu.AddItem("weapon_xm1014", "M3");
	menu.AddItem("weapon_xm1014", "XM1014");

	menu.Display(client, MENU_TIME_FOREVER);
}

public int SelectPrimaryWeapon_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_Select: {
			if (GameRules_GetProp("m_bWarmupPeriod") == 1 && IsPlayerAlive(client)) {
				char info[32];
				GetMenuItem(menu, item, info, sizeof(info));

				RemoveAllClientWeapons(client);
				GivePlayerItem2(client, "weapon_knife");
				GivePlayerItem2(client, info);
				SelectSecondaryWeapon(client);
			}
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}
}

void SelectSecondaryWeapon(int client) {
	Menu menu = new Menu(SelectSecondaryWeapon_Handler, MENU_ACTIONS_ALL);

	menu.SetTitle("➫ Wybierz pistolet: ");

	menu.AddItem("weapon_deagle", "Deagle");
	menu.AddItem("weapon_revolver", "R8 Revolver");
	menu.AddItem("weapon_fiveseven", "Five-Seven");
	menu.AddItem("weapon_tec9", "Tec-9");
	menu.AddItem("weapon_cz75a", "CZ7a");
	menu.AddItem("weapon_elite", "Dual Elites");
	menu.AddItem("weapon_p250", "P250");

	menu.Display(client, MENU_TIME_FOREVER);
}

public int SelectSecondaryWeapon_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_Select: {
			if (GameRules_GetProp("m_bWarmupPeriod") == 1 && IsPlayerAlive(client)) {
				char info[32];
				GetMenuItem(menu, item, info, sizeof(info));

				GivePlayerItem2(client, info);
			}
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}
}

public void ev_PlayerDeath_Post(Handle event, const char[] name, bool dontBroadcast) {
	int client = GetClientOfUserId(GetEventInt(event, "userid"));
	int attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	
	if (/*GetClientCount() <= 3 || */!IsPlayer(attacker) || !IsPlayer(client) || !IsClientInGame(client) || !IsClientInGame(attacker) || GetClientTeam(attacker) == GetClientTeam(client)) {
		return;
	}
	
	int assister = GetClientOfUserId(GetEventInt(event, "assister"));
	
	if (IsPlayer(assister) && IsClientInGame(assister) && g_plrClass[assister]) {
		int exp = GetConVarInt(g_cvExpForAssist);
		int coins = GetConVarInt(g_cvCoinsForAssist);
		
		g_plrExp[assister] += exp;
		CheckExp(assister);
		SetClientCoins(assister, g_plrCoins[assister] + coins);
		PrintToChat(assister, " \x06\x05+%dXP, +%d$\x01 za\x04 asyste", exp, coins);
	}
	
	if (!g_plrClass[attacker]) {
		return;
	}
	
	if (!g_plrPerk[attacker]) {
		SetClientPerk(attacker);
	}

	int exp = GetConVarInt(g_cvExpForKill), coins = GetConVarInt(g_cvCoinsForKill);
	
	if (GetEventBool(event, "headshot")) {
		exp += GetConVarInt(g_cvExpForKillByHS);
		coins += GetConVarInt(g_cvCoinsForKillByHS);
	}
	
	if (GetEventInt(event, "revenge")) {
		exp += GetConVarInt(g_cvExpForRevenge);
		coins += GetConVarInt(g_cvCoinsForRevenge);
	}

	if(g_plrLevel[client] > g_plrLevel[attacker]) {
		exp += RoundFloat(float(g_plrLevel[client] - g_plrLevel[attacker]) * GetConVarFloat(g_cvExpLevelDifference));
	}
	
	g_plrExp[attacker] += exp;
	CheckExp(attacker);
	SetClientCoins(attacker, g_plrCoins[attacker] + coins);

	PrintToChat(attacker, " \x06\x05+%dXP, +%d$\x01 za\x04 zabójstwo", exp, coins);
}

public void ev_RoundStart_Post(Handle event, const char[] name, bool dontBroadcast) {
	g_freezeTime = true;

	for(int i = 1; i <= MaxClients; i++) {
		if(g_plrTimerNextClassSkillUsage[i] != null) {
			KillTimer(g_plrTimerNextClassSkillUsage[i]);
			g_plrTimerNextClassSkillUsage[i] = null;
		}

		if(g_plrTimerNextPerkUsage[i] != null) {
			KillTimer(g_plrTimerNextPerkUsage[i]);
			g_plrTimerNextPerkUsage[i] = null;
		}

		g_plrNextClassSkillUsage[i] = 0.0;
		g_plrNextPerkUsage[i] = 0.0;
	}

	char query[512];
	Format(query, sizeof(query), "SELECT p.name, c.name, e.level, e.experience FROM codd0_players AS p INNER JOIN codd0_experience AS e ON p.playerID=e.playerID INNER JOIN codd0_classes AS c ON e.classID=c.classID ORDER BY e.experience DESC LIMIT 15;");
	SQL_TQuery(g_sqlConn, ReadTop15_Handler, query);

}

public void ReadTop15_Handler(Handle sqlConn, Handle result, const char[] error, any data) {
	if (result == null) {
		LogError("ReadTop15_Handler error: %s", error);
	} else {
		int i;

		while (SQL_MoreRows(result) && SQL_FetchRow(result)) {
			SQL_FetchString(result, 0, g_top15_name[i], 63);
			SQL_FetchString(result, 1, g_top15_class[i], 63);
			g_top15_level[i] = SQL_FetchInt(result, 2);
			g_top15_exp[i] = SQL_FetchInt(result, 3);
				
			i++;
		}
	}
}

public void ev_RoundFreezeEnd_Post(Handle event, const char[] name, bool dontBroadcast) {
	g_freezeTime = false;
}

public void ev_BombPlanted_Post(Handle event, const char[] name, bool dontBroadcast) {
	if (GetClientCount() <= 3) {
		return;
	}

	int client = GetClientOfUserId(GetEventInt(event, "userid"));

	if (!IsPlayer(client) || !IsClientInGame(client) || !g_plrClass[client]) {
		return;
	}

	int exp = GetConVarInt(g_cvExpForBombPlanting), coins = GetConVarInt(g_cvCoinsForBombPlanting);

	g_plrExp[client] += exp;
	CheckExp(client);
	SetClientCoins(client, g_plrCoins[client] + coins);

	PrintToChat(client, " \x06\x05+%dXP, +%d$\x01 za\x04 podłożenie paki", exp, coins);
}

public void ev_BombDefused_Post(Handle event, const char[] name, bool dontBroadcast) {
	if (GetClientCount() <= 3) {
		return;
	}

	int client = GetClientOfUserId(GetEventInt(event, "userid"));

	if (!IsPlayer(client) || !IsClientInGame(client) || !g_plrClass[client]) {
		return;
	}

	int exp = GetConVarInt(g_cvExpForBombDefusing), coins = GetConVarInt(g_cvCoinsForBombDefusing);

	g_plrExp[client] += exp;
	CheckExp(client);
	SetClientCoins(client, g_plrCoins[client] + coins);

	PrintToChat(client, " \x06\x05+%dXP, +%d$\x01 za\x04 rozbrojenie paki", exp, coins);
}

public void ev_HostRescued_Post(Handle event, const char[] name, bool dontBroadcast) {
	if (GetClientCount() <= 3) {
		return;
	}
	
	int client = GetClientOfUserId(GetEventInt(event, "userid"));

	if (!IsPlayer(client) || !IsClientInGame(client) || !g_plrClass[client]) {
		return;
	}

	new exp = GetConVarInt(g_cvExpForHostage), coins = GetConVarInt(g_cvCoinsForHostage);

	g_plrExp[client] += exp;
	CheckExp(client);
	SetClientCoins(client, g_plrCoins[client] + coins);

	PrintToChat(client, " \x06\x05+%dXP, +%d$\x01 za\x04 uratowanie zakładnika", exp, coins);
}

public void ev_RoundEnd_Post(Handle event, const char[] name, bool dontBroadcast) {
	if (GetClientCount() <= 3) {
		return;
	}
	
	int team = GetEventInt(event, "winner"), exp = GetConVarInt(g_cvExpForWinningRound), coins = GetConVarInt(g_cvCoinsForWinningRound);

	for (int client = 1; client <= MaxClients; client++) {
		if (!IsClientInGame(client)) {
			continue;
		}

		if(g_plrClass[client] && team == GetClientTeam(client)) {
			g_plrExp[client] += exp;
			CheckExp(client);
			SetClientCoins(client, g_plrCoins[client] + coins);

			PrintToChat(client, " \x06\x05+%dXP, +%d$\x01 za\x04 wygranie rundy", exp, coins);
		}
	}
}

public Action ev_Sound(int clients[64], int &clientsNum, char sound[PLATFORM_MAX_PATH], int &ent, int &channel, float &volume, int &level, int &pitch, int &flags) {
	if (g_freezeTime && StrEqual(sound, "items/itempickup.wav")) {
		return Plugin_Stop;
	}
	
	return Plugin_Continue;
}

public Action cmd_SelectClass(int client, int args) {
	if (g_isPlayerDataLoading[client] || g_isPlayerClassDataLoading[client]) {
		PrintToChat(client, " \x06\x04%s\x01 Trwa wczytywanie danych gracza...Menu będzie dostępne po wczytaniu.", g_prefix);
		return Plugin_Handled;
	}

	if (GameRules_GetProp("m_bWarmupPeriod") == 1) {
		PrintToChat(client, " \x06\x04%s\x01 Wybieranie klasy dostępne po rozgrzewce.", g_prefix);
		return Plugin_Handled;
	}
	
	Menu menu = new Menu(SelectClass_Handler);
	int classID;
	char item[128], info[8];
	
	menu.SetTitle("➫ Wybierz klase:");
	
	for (int i = 1; i <= g_classesNum; i++) {
		classID = g_sortedClassesOrder[i];

		if (!g_isClassAvailable[classID]) {
			continue;
		}
		
		IntToString(classID, info, sizeof(info));
		Format(item, sizeof(item), "★ %s [%dLv] ★", g_className[classID], g_plrClassLevel[client][classID]);
		menu.AddItem(info, item);
	}
	
	menu.Display(client, MENU_TIME_FOREVER);
	return Plugin_Handled;
}

public int SelectClass_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_Select: {
			Menu menu2 = new Menu(ConfirmClass_Handler);

			char weaponAlias[32], weaponsNames[256], info[8], classDesc[MAX_CLASSDESC_LENGTH+1], desc[512];
			int len, classID;

			menu.GetItem(item, info, sizeof(info));
			classID = g_plrLastSelectedClass[client] = StringToInt(info);
			
			for (int i = 0; i < g_classWeaponsNum[classID]; i++) {
				CS_WeaponIDToAlias(g_classWeapon[classID][i], weaponAlias, sizeof(weaponAlias));
				len += Format(weaponsNames[len], sizeof(weaponsNames) - len, "%s ", weaponAlias);
			}
			
			ReplaceString(weaponsNames, sizeof(weaponsNames), "_silencer", "-s");
			//len = 0;

			len = strlen(g_classDesc[classID]);
			strcopy(classDesc, MAX_CLASSDESC_LENGTH, g_classDesc[classID]);

			if (len >= 90) {
				for (int i = 90; i < len; i++) {
					if (classDesc[i] == ' ') {
						Format(classDesc[i], len - i, "\n%s", classDesc[i]);
						break;
					}
				}
			}
			
			Format(desc, sizeof(desc), "➫ Czy potwierdzasz wybór klasy?\n♦ Nazwa: %s\n♦ Opis: %s\n♦ Bronie: %s\n♦ Staty: %d inteligencji, %d zdrowia\n%d wytrzymałości, %d szybkości",
								g_className[classID], classDesc, weaponsNames, g_classStats[classID][INT_PTS], g_classStats[classID][HEALTH_PTS], 
								g_classStats[classID][STAMINA_PTS], g_classStats[classID][SPEED_PTS]);

			menu2.SetTitle(desc);
			menu2.AddItem("", "✓ Tak ✓");
			menu2.AddItem("", "✗ Nie ✗");
			menu2.ExitButton = false;
			menu2.Display(client, MENU_TIME_FOREVER);
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}
}

public int ConfirmClass_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_Select: {
			if (!item) {
				PrepareNewPlayerClass(client, g_plrLastSelectedClass[client]);
			} else {
				cmd_SelectClass(client, 0);
			}
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}
}

public Action cmd_PerkDesc(int client, int args) {
	if (g_plrPerk[client]) {
		char desc[MAX_PERKDESC_LENGTH + 1];
		int perkID = g_plrPerk[client];
		
		strcopy(desc, MAX_PERKDESC_LENGTH, g_perkDesc[perkID]);
		
		if (StrContains(desc, "LW") != -1) {
			char perkValue[8];
			
			IntToString(g_plrPerkValue[client], perkValue, sizeof(perkValue));
			ReplaceString(desc, MAX_PERKDESC_LENGTH, "LW", perkValue);
		}
		
		PrintToChat(client, " \x06\x04%s\x01 Perk: \x06\x05 %s", g_prefix, g_perkName[perkID]);
		PrintToChat(client, " \x06\x04%s\x01 Opis: \x06\x05 %s", g_prefix, desc);
	} else {
		PrintToChat(client, " \x06\x04%s\x01 Nie posiadasz żadnego perku!", g_prefix);
	}
	
	return Plugin_Handled;
}

//Support for !drop
public Action OnClientSayCommand(int client, const char[] command, const char[] args) {
	//PrintToChat(client, "cmd: %s, args: %s", command, args);

	if (strcmp(command, "say", false)) {
		return Plugin_Continue;
	}

	char sValue[32];

	strcopy(sValue, sizeof(sValue), args);
	StripQuotes(sValue);
	TrimString(sValue);

	if(StrEqual(sValue, "!drop")) {
		cmd_DropPerk(client, 0);
	}

	return Plugin_Continue;
}

public Action cmd_DropPerk(int client, int args) {
	if (!g_plrPerk[client]) {
		PrintToChat(client, " \x06\x04%s\x01 Nie posiadasz żadnego perku!", g_prefix);
		return Plugin_Handled;
	}
	
	PrintToChat(client, " \x06\x04%s\x01 Wyrzuciłeś \x06\x05 %s", g_prefix, g_perkName[g_plrPerk[client]]);
	SetClientPerk(client, 0);
	
	return Plugin_Handled;
}

public Action cmd_AssignStatsPoints(client, iArg) {
	if (!g_plrClass[client]) {
		PrintToChat(client, " \x06\x04%s\x01 Nie wybrałeś żadnej klasy!", g_prefix);
		return Plugin_Handled;
	}

	if (g_isPlayerClassDataLoading[client]) {
		PrintToChat(client, " \x06\x04%s\x01 Trwa wczytywanie danych...", g_prefix);
		return Plugin_Handled;
	}
	
	char item[128];
	char statName[][] =  { "", "ฝ Inteligencja ฝ", "♥ Zdrowie ♥", "♜ Wytrzymałość ♜", "♝ Szybkość ♝" };
	char statDesc[][] = { "", "zwiększa umiejętności klas/perków", "zwiększa ilość zdrowia", "zwiększa ilość kamizelki", "zwiększa prędkość biegu" };
	
	Menu menu = new Menu(AssignStatsPoints_Handler, MENU_ACTIONS_ALL);
	int classID = g_plrClass[client];
	
	Format(item, 63, "➫ Rozdaj punkty [%d]", g_plrStatsPoints[client][TOASSIGN_PTS]);
	menu.SetTitle(item);
	
	for (int i = 1; i <= 4; i++) {
		Format(item, sizeof(item), "%s [%s]: %d", statName[i], statDesc[i], g_plrStatsPoints[client][i] + g_classStats[classID][i] + g_plrBonusStatsPoints[client][i]);
		menu.AddItem(statName[i], item);
	}

	Format(item, sizeof(item), "✢ Rozdawaj po: %d pkt.", g_statsPointsToAssign[g_plrStatsPointsToAssignID[client]]);
	menu.AddItem("", item)
	
	menu.Display(client, MENU_TIME_FOREVER);
	return Plugin_Handled;
}

public int AssignStatsPoints_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_Select: {
			if (IsPlayer(client) && g_plrStatsPoints[client][TOASSIGN_PTS] > 0 && !g_isPlayerClassDataLoading[client]) {
				switch(item) {
					case 0, 1, 2, 3: {
						int pointsToAssign = GetLowerValue(g_plrStatsPoints[client][TOASSIGN_PTS], g_statsPointsToAssign[g_plrStatsPointsToAssignID[client]]);
						int limit = 50;
						int statID = item + 1;

						if((g_plrStatsPoints[client][statID]+pointsToAssign) > limit) {
							pointsToAssign = limit - g_plrStatsPoints[client][statID];
						}

						g_plrStatsPoints[client][statID] += pointsToAssign;
						g_plrStatsPoints[client][TOASSIGN_PTS] -= pointsToAssign;

						if(g_plrStatsPoints[client][statID] == limit) {
							char info[32];
							
							menu.GetItem(item, info, sizeof(info));
							PrintToChat(client, " \x06\x04%s\x01 Statystyka \x05 %s\x01 osiągnęła poziom maksymalny!", g_prefix, info);
						}
						
						if (g_plrStatsPoints[client][TOASSIGN_PTS] > 0) {
							cmd_AssignStatsPoints(client, 0);
						}
					}

					case 4: {
						if(++g_plrStatsPointsToAssignID[client] >= sizeof(g_statsPointsToAssign)) {
							g_plrStatsPointsToAssignID[client] = 0;
						}

						cmd_AssignStatsPoints(client, 0);
					}
				}
			}
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}
}

public Action cmd_ClassesDescs(int client, int args) {
	Menu menu = new Menu(ClassesDescs_Handler, MENU_ACTIONS_ALL);
	int classID;
	char info[8], item[64];

	menu.SetTitle("➫ Opisy klas:");
	
	for (int i = 1; i <= g_classesNum; i++) {
		classID = g_sortedClassesOrder[i];

		if(!g_isClassAvailable[classID]) {
			continue;
		}

		IntToString(classID, info, sizeof(info));
		Format(item, sizeof(item), "★ %s ★", g_className[classID]);
		menu.AddItem(info, item);
	}
	
	menu.Display(client, MENU_TIME_FOREVER);
	return Plugin_Handled;
}

public int ClassesDescs_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_Select: {
			Menu menu2 = new Menu(CheckClassDesc_Handler, MENU_ACTIONS_ALL);

			char weaponAlias[32], weaponsNames[256], info[8], classDesc[MAX_CLASSDESC_LENGTH+1], desc[512];
			int len, classID;

			menu.GetItem(item, info, sizeof(info));
			classID = StringToInt(info);
			
			for (int i = 0; i < g_classWeaponsNum[classID]; i++) {
				CS_WeaponIDToAlias(g_classWeapon[classID][i], weaponAlias, sizeof(weaponAlias));
				len += Format(weaponsNames[len], sizeof(weaponsNames) - len, "%s ", weaponAlias);
			}
			
			ReplaceString(weaponsNames, sizeof(weaponsNames), "_silencer", "-s");

			len = strlen(g_classDesc[classID]);
			strcopy(classDesc, MAX_CLASSDESC_LENGTH, g_classDesc[classID]);

			if (len >= 90) {
				for (int i = 90; i < len; i++) {
					if (classDesc[i] == ' ') {
						Format(classDesc[i], len - i, "\n%s", classDesc[i]);
						break;
					}
				}
			}
			
			Format(desc, sizeof(desc), "♦ Nazwa: %s\n♦ Opis: %s\n♦ Bronie: %s\n♦ Staty: %d inteligencji, %d zdrowia\n%d wytrzymałości, %d szybkości",
								g_className[classID], classDesc, weaponsNames, g_classStats[classID][INT_PTS], g_classStats[classID][HEALTH_PTS], 
								g_classStats[classID][STAMINA_PTS], g_classStats[classID][SPEED_PTS]);

			menu2.SetTitle(desc);
			menu2.AddItem("", "Powrót do opisu klas");
			menu2.Display(client, MENU_TIME_FOREVER);
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}
}


public int CheckClassDesc_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_Select: {
			cmd_ClassesDescs(client, 0);
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}
}

public Action cmd_PerksDescs(int client, int args) {
	Menu menu = new Menu(PerksDescs_Handler, MENU_ACTIONS_ALL);
	int perkID;
	char info[8], item[64];

	menu.SetTitle("➫ Opisy perków:");
	
	for (int i = 1; i <= g_perksNum; i++) {
		perkID = g_sortedPerksOrder[i];

		IntToString(perkID, info, sizeof(info));
		Format(item, sizeof(item), "★ %s ★", g_perkName[perkID]);
		menu.AddItem(info, item);
	}
	
	menu.Display(client, MENU_TIME_FOREVER);
	return Plugin_Handled;
}

public PerksDescs_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_Select: {
			char info[8], desc[MAX_PERKDESC_LENGTH + 1];

			menu.GetItem(item, info, sizeof(info));
			int perkID = StringToInt(info);

			strcopy(desc, MAX_PERKDESC_LENGTH, g_perkDesc[perkID]);
			
			if (StrContains(desc, "LW") != -1) {
				char perkValue[16];
				
				Format(perkValue, sizeof(perkValue), "%d-%d", g_perkValue[perkID][0], g_perkValue[perkID][1]);
				ReplaceString(desc, MAX_PERKDESC_LENGTH, "LW", perkValue);
			}
			
			PrintToChat(client, " \x06\x04%s\x01 Perk:\x05 %s", g_prefix, g_perkName[perkID]);
			PrintToChat(client, " \x06\x04%s\x01 Opis:\x05 %s", g_prefix, desc);
			
			cmd_PerksDescs(client, 0);
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}
}

public Action cmd_ResetStatsPoints(int client, int args) {
	if (!g_plrClass[client] || g_plrLevel[client] <= 1) {
		return Plugin_Handled;
	}
	
	for (int i = 1; i <= 4; i++) {
		g_plrStatsPoints[client][i] = 0;
	}
	
	g_plrStatsPoints[client][TOASSIGN_PTS] = g_plrLevel[client] - 1;
	cmd_AssignStatsPoints(client, 0);
	
	PrintToChat(client, " \x06\x04%s\x01 Twoje punkty statystyk zostały zresetowane!", g_prefix);
	return Plugin_Handled;
}

public Action cmd_UsePerk(int client, int args) {
	if (!g_plrPerk[client] || !IsPlayerAlive(client)) {
		return Plugin_Handled;
	}
	
	float gameTime = GetGameTime(), nextUsage = g_plrNextPerkUsage[client];

	if (nextUsage > gameTime) {
		PrintCenterText(client, "Umiejętność będzie dostępna za %d sec.!", RoundToCeil(nextUsage-gameTime));
		return Plugin_Handled;
	}

	Call_StartForward(g_fwPerkUsed);
	Call_PushCell(client);
	Call_PushCell(g_plrPerk[client]);
	Call_Finish();
	
	return Plugin_Handled;
}

public Action cmd_UseClassSkill(int client, int args) {
	if (!g_plrClass[client] || !IsPlayerAlive(client)) {
		return Plugin_Handled;
	}
	
	
	float gameTime = GetGameTime(), nextUsage = g_plrNextClassSkillUsage[client];

	if (nextUsage > gameTime) {
		PrintCenterText(client, "Umiejętność będzie dostępna za %d sec.!", RoundToCeil(nextUsage-gameTime));
		return Plugin_Handled;
	}

	Call_StartForward(g_fwClassSkillUsed);
	Call_PushCell(client);
	Call_PushCell(g_plrClass[client]);
	Call_Finish();
	
	return Plugin_Handled;
}

public Action cmd_Binds(int client, int args) {
	Menu menu = new Menu(Binds_Handler, MENU_ACTIONS_ALL);
	SetMenuTitle(menu, "➫ Do użycia umiejętności służą standardowo\n \
						E (dla klasy) oraz G (dla perku). Można\n \
						jednak bindować komendy Use_Class\n \
						oraz Use_Perk pod własne guziki.\n \
						➫ Krótki poradnik bindowania \n \
						1. Odblokuj konsolę w ustawieniach\n \
						2. Otwórz ją przez naciśnięcie ~\n \
						3. Wpisz następujący kod (jest też w konsoli)\n \
						bind v Use_Class; bind c Use_Perk\n \
						4. Kliknij Enter\n\n \
						Od teraz po klknięciu V aktywujesz umiejętność klasy\n \
						A pod C - umiejętność perku");
	
	menu.AddItem("", "#");
	menu.Display(client, MENU_TIME_FOREVER);
	return Plugin_Handled;
}

public int Binds_Handler(Menu menu, MenuAction action, int client, int item) {
	switch(action) {
		case MenuAction_DrawItem: {
			return ITEMDRAW_SPACER;
		}

		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
	}

	return 0;
}

public Action cmd_Top15(int client, int args) {
	char item[256];
	Menu menu = new Menu(Top15_Handler, MENU_ACTIONS_ALL);
	float percent;
	
	menu.SetTitle("✶ TOP 15 graczy ✶");
	
	for(int i = 0; i < 15; i++) {
		percent = float(g_top15_exp[i] - g_levelExp[g_top15_level[i] - 1]) / float(g_levelExp[g_top15_level[i]] - g_levelExp[g_top15_level[i] - 1]) * 100.0;
		Format(item, sizeof(item), "Poz. #%d - %s :: %s :: %d Lv [%.1f%%  dośw.]", i+1, g_top15_name[i], g_top15_class[i], g_top15_level[i], percent);
		menu.AddItem("", item);
	}

	menu.Display(client, MENU_TIME_FOREVER);
	return Plugin_Handled;
}


public int Top15_Handler(Menu menu, MenuAction action, int client, int item) {
	switch (action) {
		case MenuAction_End: {
			if(menu != null) {
				delete menu;
			}
		}
		
		case MenuAction_DrawItem: {
			return ITEMDRAW_DISABLED;
		}
	}

	return 0;
}

public Action cmd_Rank(int client, int args) {
	char query[512];

	Format(query, sizeof(query), "SELECT COUNT(*) FROM codd0_experience WHERE experience>=%d", g_plrExp[client]);
	SQL_TQuery(g_sqlConn, Rank_Handler, query, GetClientUserId(client));
	
	return Plugin_Handled;
}

public void Rank_Handler(Handle sqlConn, Handle result, const char[] error, any userID) {
	if (result == null) {
		LogError("Rank_Handler error: %s", error);
	} else {
		int client = GetClientOfUserId(userID);

		if (!client) {
			return;
		}

		if (SQL_MoreRows(result) && SQL_FetchRow(result)) {
			PrintToChat(client, " \x06\x04[COD:MW]\x01 Zajmujesz\x0E #%d\x01 miejsce w rankingu.", SQL_FetchInt(result, 0));
		}
	}
}

public void OnClientCookiesCached(int client) {
	char value[8];

	GetClientCookie(client, g_cookieSoundEffect, value, sizeof(value));
	g_soundEffects[client] = !StrEqual(value, "0");
	GetClientCookie(client, g_cookieHudMode, value, sizeof(value));
	g_hudType[client] = StringToInt(value);
}

public void cookie_LevelUpSound(int client, CookieMenuAction action, any info, char[] buffer, int len) {
	if(action == CookieMenuAction_SelectOption) {
		g_soundEffects[client] = !g_soundEffects[client];

		SetClientCookie(client, g_cookieSoundEffect, g_soundEffects[client] ? "1" : "0");
		PrintToChat(client, " \x06\x04[COD:MW]\x01 Dźwięk LVL UP:\x05 %s", g_soundEffects[client] ? "włączony" : "wyłączony");
		
		ShowCookieMenu(client);
	}
}

public void cookie_HUDMode(int client, CookieMenuAction action, any info, char[] buffer, int len) {
	if(action == CookieMenuAction_SelectOption) {
		char value[4];

		if(++g_hudType[client] >= 3) {
			g_hudType[client] = 0;
		}

		IntToString(g_hudType[client], value, sizeof(value));

		SetClientCookie(client, g_cookieHudMode, value);
		PrintToChat(client, " \x06\x04[COD:MW]\x01 HUD:\x05 %s", (g_hudType[client] == 0) ? "HINT Text" : ((g_hudType[client] == 1) ? "Do góry" : "Brak"));
		
		ShowCookieMenu(client);
	}
}

public Action cmd_GiveExp(int client, int args) {
	if(args != 2) {
		PrintToConsole(client, "Usage: cod_givexp <nick> <value>");
		return Plugin_Handled;
	}
 
	char targetName[64];
	GetCmdArg(1, targetName, sizeof(targetName));
	int target = FindTarget(client, targetName, true, true);

	if(target <= 0) {
		ReplyToCommand(client, "*** Nie znaleziono danego gracza");
		return Plugin_Handled;
	}

	if(!g_plrClass[target]) {
		ReplyToCommand(client, "*** Gracz nie wybrał żadnej klasy");
		return Plugin_Handled;
	}

	int exp;
	char sExp[32];

	GetCmdArg(2, sExp, sizeof(sExp));
	exp = StringToInt(sExp);

	if(exp <= 0) {
		ReplyToCommand(client, "*** Podana wartość jest niepoprawna");
		return Plugin_Handled;
	}

	GetClientName(target, targetName, sizeof(targetName));
	g_plrExp[target] += exp;
	CheckExp(target);

	PrintToConsole(client, "*** Graczowi %s dodano +%d doświadczenia", targetName, exp);
	return Plugin_Handled;
}

public Action cmd_SetExp(int client, int args) {
	if (args != 2) {
		PrintToConsole(client, "Usage: cod_setxp <nick> <value>");
		return Plugin_Handled;
	}
 
	char targetName[64];
	GetCmdArg(1, targetName, sizeof(targetName));
	int target = FindTarget(client, targetName, true, true);

	if(target <= 0) {
		ReplyToCommand(client, "*** Nie znaleziono danego gracza");
		return Plugin_Handled;
	}

	if(!g_plrClass[target]) {
		ReplyToCommand(client, "*** Gracz nie wybrał żadnej klasy");
		return Plugin_Handled;
	}

	int exp;
	char sExp[32];

	GetCmdArg(2, sExp, sizeof(sExp));
	exp = StringToInt(sExp);

	if(exp < 0) {
		ReplyToCommand(client, "*** Podana wartość jest niepoprawna");
		return Plugin_Handled;
	}

	GetClientName(target, targetName, sizeof(targetName));
	g_plrExp[target] = exp;
	CheckExp(target);

	PrintToConsole(client, "*** Graczowi %s ustawiono %d doświadczenia", targetName, exp);
	return Plugin_Handled;
}

public Action cmd_GiveLevel(int client, int args) {
	if(args != 2) {
		PrintToConsole(client, "Usage: cod_givelvl <nick> <value>");
		return Plugin_Handled;
	}
 
	char targetName[64];
	GetCmdArg(1, targetName, sizeof(targetName));
	int target = FindTarget(client, targetName, true, true);

	if(target <= 0) {
		ReplyToCommand(client, "*** Nie znaleziono danego gracza");
		return Plugin_Handled;
	}

	if(!g_plrClass[target]) {
		ReplyToCommand(client, "*** Gracz nie wybrał żadnej klasy");
		return Plugin_Handled;
	}

	int level;
	char sLevel[16];

	GetCmdArg(2, sLevel, sizeof(sLevel));
	level = StringToInt(sLevel);

	if(level <= 0) {
		ReplyToCommand(client, "*** Podana wartość jest niepoprawna");
		return Plugin_Handled;
	}

	GetClientName(target, targetName, sizeof(targetName));
	g_plrExp[target] = g_levelExp[GetLowerValue(g_plrLevel[target] + level - 1, sizeof(g_levelExp))];
	CheckExp(target);

	PrintToConsole(client, "*** Graczowi %s dodano +%d poziom", targetName, sLevel);
	return Plugin_Handled;
}

public Action cmd_SetLevel(int client, int args) {
	if(args != 2) {
		PrintToConsole(client, "Usage: cod_setlvl <nick> <value>");
		return Plugin_Handled;
	}
 
	char targetName[64];
	GetCmdArg(1, targetName, sizeof(targetName));
	int target = FindTarget(client, targetName, true, true);

	if(target <= 0) {
		ReplyToCommand(client, "*** Nie znaleziono danego gracza");
		return Plugin_Handled;
	}

	if(!g_plrClass[target]) {
		ReplyToCommand(client, "*** Gracz nie wybrał żadnej klasy");
		return Plugin_Handled;
	}

	int level;
	char sLevel[16];

	GetCmdArg(2, sLevel, sizeof(sLevel));
	level = StringToInt(sLevel);

	if(level <= 0) {
		ReplyToCommand(client, "*** Podana wartość jest niepoprawna");
		return Plugin_Handled;
	}

	GetClientName(target, targetName, sizeof(targetName));
	g_plrExp[target] = g_levelExp[GetLowerValue(level - 1, sizeof(g_levelExp))];
	CheckExp(target);

	PrintToConsole(client, "*** Graczowi %s ustawiono %d poziom", targetName, level);
	return Plugin_Handled;
}


public Action cmd_GiveCoins(int client, int args) {
	if(args != 2) {
		PrintToConsole(client, "Usage: cod_givecoins <nick> <value>");
		return Plugin_Handled;
	}
 
	char targetName[64];
	GetCmdArg(1, targetName, sizeof(targetName));
	int target = FindTarget(client, targetName, true, true);

	if(target <= 0) {
		ReplyToCommand(client, "*** Nie znaleziono danego gracza");
		return Plugin_Handled;
	}


	if(g_isPlayerDataLoading[target]) {
		ReplyToCommand(client, "*** Dane gracza nie zostały jeszcze wczytane");
		return Plugin_Handled;
	}

	int coins;
	char sCoins[32];

	GetCmdArg(2, sCoins, sizeof(sCoins));
	coins = StringToInt(sCoins);

	if(coins <= 0) {
		ReplyToCommand(client, "*** Podana wartość jest niepoprawna");
		return Plugin_Handled;
	}

	GetClientName(target, targetName, sizeof(targetName));
	SetClientCoins(target, g_plrCoins[target] + coins);

	PrintToConsole(client, "*** Graczowi %s dodano +%d$", targetName, coins);
	return Plugin_Handled;
}

public Action cmd_SetCoins(int client, int args) {
	if(args != 2) {
		PrintToConsole(client, "Usage: cod_setcoins <nick> <value>");
		return Plugin_Handled;
	}
 
	char targetName[64];
	GetCmdArg(1, targetName, sizeof(targetName));
	int target = FindTarget(client, targetName, true, true);

	if(target <= 0) {
		ReplyToCommand(client, "*** Nie znaleziono danego gracza");
		return Plugin_Handled;
	}


	if(g_isPlayerDataLoading[target]) {
		ReplyToCommand(client, "*** Dane gracza nie zostały jeszcze wczytane");
		return Plugin_Handled;
	}

	int coins;
	char sCoins[32];

	GetCmdArg(2, sCoins, sizeof(sCoins));
	coins = StringToInt(sCoins);

	if(coins < 0) {
		ReplyToCommand(client, "*** Podana wartość jest niepoprawna");
		return Plugin_Handled;
	}

	GetClientName(target, targetName, sizeof(targetName));
	SetClientCoins(target, coins);

	PrintToConsole(client, "*** Graczowi %s ustawiono +%d$", targetName, coins);
	return Plugin_Handled;
}

public Action cmd_SetPerk(int client, int args) {
	if(args < 2) {
		PrintToConsole(client, "Usage: cod_setperk <nick> <perk's name> [perk's value]");
		return Plugin_Handled;
	}
 
	char targetName[64];
	GetCmdArg(1, targetName, sizeof(targetName));
	int target = FindTarget(client, targetName, true, true);

	if(target <= 0) {
		ReplyToCommand(client, "*** Nie znaleziono danego gracza");
		return Plugin_Handled;
	}

	if(!g_plrClass[target]) {
		ReplyToCommand(client, "*** Gracz nie wybrał żadnej klasy");
		return Plugin_Handled;
	}

	int perkID, perkValue = -1;
	char perkName[MAX_PERKNAME_LENGTH+1];

	GetCmdArg(2, perkName, sizeof(perkName));
	perkID = GetPerkID(perkName);

	if(!perkID) {
		PrintToConsole(client, "*** Nie znaleziono perku");
		return Plugin_Handled;
	}

	if(args == 3) {
		char sPerkValue[32];

		GetCmdArg(3, sPerkValue, sizeof(sPerkValue));
		perkValue = StringToInt(sPerkValue);
	}

	GetClientName(target, targetName, sizeof(targetName));
	SetClientPerk(target, perkID, perkValue);
	PrintToConsole(client, "*** Graczowi %s ustawiono perk %s", targetName, perkName);
	return Plugin_Handled;
}

public Action timer_HUD(Handle timer, any serial) {
	if (GameRules_GetProp("m_bWarmupPeriod") == 1) {
		return Plugin_Continue;
	}
	
	new client = GetClientFromSerial(serial);
	
	if (!client) {
		return Plugin_Stop;
	}

	int target = IsPlayerAlive(client) ? client : GetEntPropEnt(client, Prop_Send, "m_hObserverTarget");
    
	if (!IsPlayer(target) || g_isPlayerDataLoading[target] || g_isPlayerClassDataLoading[target]) {
		return Plugin_Continue;
	}

	switch(g_hudType[client]) {
    	case 0: {
    		char clanName[32];
    		CodD0_GetClientClanName(target, clanName, sizeof(clanName));

    		PrintHintText(client, "<font color='#ffff00'><b>[Klasa: %s (%d Lv | %.1f %%)]<br>[Perk: %s | Monety: %d$]<br>[Misja: %d/%d | Klan: %s]</b></font>", 
    			g_className[g_plrClass[target]], g_plrLevel[target], 
				float(g_plrExp[target] - g_levelExp[g_plrLevel[target]-1]) / float(g_levelExp[g_plrLevel[target]] - g_levelExp[g_plrLevel[target]-1]) * 100.0, 
				g_perkName[g_plrPerk[target]], g_plrCoins[target], MEd0_GetClientMissionPrgrs(target), MEd0_GetMissionReqPrgrs(MEd0_GetClientMission(target)), clanName);
    	}

    	case 1: {
    		SetHudTextParams(-1.0, 0.07, 2.0, 0, 255, 0, 0, 0, 0.0, 0.0, 0.0);
    		ShowSyncHudText(client, g_hudSync, "[Klasa: %s (%d Lv | %.1f %%)]\n[Perk: %s | Misja: %d/%d]", g_className[g_plrClass[target]], g_plrLevel[target], 
				float(g_plrExp[target] - g_levelExp[g_plrLevel[target]-1]) / float(g_levelExp[g_plrLevel[target]] - g_levelExp[g_plrLevel[target]-1]) * 100.0, 
				g_perkName[g_plrPerk[target]], MEd0_GetClientMissionPrgrs(target), MEd0_GetMissionReqPrgrs(MEd0_GetClientMission(target)));
    	}
	}
	
	return Plugin_Continue;
}

void CheckExp(int client) {
	int isLevelChanged;//, classID = g_plrClass[client];
	
	while (g_plrExp[client] >= g_levelExp[g_plrLevel[client]] && g_plrLevel[client] < sizeof(g_levelExp)) {
		g_plrLevel[client] ++;
		isLevelChanged = 1;
	}

	while (g_plrExp[client] < g_levelExp[g_plrLevel[client] - 1]) {
		g_plrLevel[client] --;
		isLevelChanged = -1;
	}
	
	switch(isLevelChanged) {
		case -1: {
			PrintToChat(client, " \x06\x04%s \x06\x05Niestety! Spadłeś do %d poziomu!", g_prefix, g_plrLevel[client]);
		}

		case 1: {
			g_plrStatsPoints[client][TOASSIGN_PTS] = g_plrLevel[client] - 1 - g_plrStatsPoints[client][1] - g_plrStatsPoints[client][2] - g_plrStatsPoints[client][3] - g_plrStatsPoints[client][4];
				
			if(g_soundEffects[client]) {
				ClientCommand(client, "play */CodMod_d0naciak/engine/level_up.mp3");
			}

			PrintToChat(client, " \x06\x04%s \x06\x05Gratulacje! Awansowałeś do %d poziomu!", g_prefix, g_plrLevel[client]);
		}
	}
}

public int nat_RegisterClass(Handle plugin, int paramsNum) {
	int classID, statsPoints[4], weaponsNum;
	char name[MAX_CLASSNAME_LENGTH+1];
	int weapons[MAX_CLASSWEAPONSNUM];

	GetNativeString(1, name, MAX_CLASSNAME_LENGTH);

	for (int i = 1; i <= g_classesNum; i++) {
		if(StrEqual(name, g_className[i])) {
			classID = i;
			break;
		}
	}

	if (!classID) {
		if (g_classesNum >= MAX_CLASSESNUM) {
			LogError("Data limit for classes has been reached. Class '%s' won't be registered", name);
			return -1;
		}

		classID = ++g_classesNum;
	}
	
	g_className[classID] = name;
	GetNativeString(2, g_classDesc[classID], MAX_CLASSDESC_LENGTH);
	weaponsNum = GetNativeCell(5);
	GetNativeArray(3, statsPoints, 4);
	GetNativeArray(4, weapons, weaponsNum); //check that shit
	g_classWeaponsNum[classID] = weaponsNum;

	for (int i = 0; i < weaponsNum; i++) {
		g_classWeapon[classID][i] = view_as<CSWeaponID>(weapons[i]);
	}
	
	for (int i = 0; i < 4; i++) {
		g_classStats[classID][i+1] = statsPoints[i];
	}

	if(g_allPluginsLoaded) {
		char query[256], escapedName[MAX_CLASSNAME_LENGTH*2+1];

		SQL_EscapeString(g_sqlConn, name, escapedName, MAX_CLASSNAME_LENGTH*2);
		Format(query, sizeof(query), "SELECT classID FROM codd0_classes WHERE name='%s'", escapedName);
		SQL_TQuery(g_sqlConn, IsClassInDB_Handler, query, classID);
	}
	
	return classID;
}

public void IsClassInDB_Handler(Handle sqlConn, Handle result, const char[] error, any classID) {
	if(result == null) {
		LogError("IsClassInDB_Handler error: %s", error);
		return;
	}

	if (SQL_FetchRow(result)) {
		g_isClassAvailable[classID] = true;
		SortClasses();
	} else {
		char query[256], escapedName[MAX_CLASSNAME_LENGTH*2+1];

		SQL_EscapeString(g_sqlConn, g_className[classID], escapedName, MAX_CLASSNAME_LENGTH*2);
		Format(query, sizeof(query), "INSERT INTO codd0_classes (name) VALUES ('%s');", escapedName);
		SQL_TQuery(g_sqlConn, InsertClassToDB_Handler, query, classID);
	}
}

public void InsertClassToDB_Handler(Handle sqlConn, Handle result, const char[] error, any classID) {
	if(result == null) {
		LogError("InsertClassToDB_Handler error: %s", error);
		return;
	}

	g_isClassAvailable[classID] = true;
	SortClasses();
}

public int nat_UnregisterClass(Handle plugin, int paramsNum) {
	int classID = GetNativeCell(1);

	g_isClassAvailable[classID] = false;
	SortClasses();

	for(new i = 1; i <= MaxClients; i++) {
		if(IsClientInGame(i) && g_plrClass[i] == classID) {
			SetClientClass(i, 0);

			PrintToChat(i, " \x06\x04%s\x01 Twoja została przeładowana przez serwer.", g_prefix);
			PrintToChat(i, " \x06\x04%s\x01 Musisz ją wybrać ponownie poprzez menu !klasa", g_prefix);
		}
	}
}

public int nat_RegisterPerk(Handle plugin, int paramsNum) {
	int perkID;
	char name[MAX_PERKNAME_LENGTH+1];

	GetNativeString(1, name, MAX_PERKNAME_LENGTH);

	for (int i = 1; i <= g_perksNum; i++) {
		if(StrEqual(name, g_perkName[i])) {
			perkID = i;
			break;
		}
	}

	if(!perkID) {
		if (g_perksNum >= MAX_PERKSNUM) {
			LogError("Data limit for perks has been reached. Perk '%s' won't be registered", name);
			return -1;
		}

		perkID = ++g_perksNum;
	}
	
	g_perkName[perkID] = name;
	GetNativeString(2, g_perkDesc[perkID], MAX_PERKDESC_LENGTH);
	
	if (paramsNum > 2) {
		g_perkValue[perkID][0] = GetNativeCell(3);
		g_perkValue[perkID][1] = GetNativeCell(4);
	}


	if(g_allPluginsLoaded) {
		SortPerks();
	}
	
	return perkID;
}

public int nat_UnregisterPerk(Handle plugin, int paramsNum) {
	int perkID = GetNativeCell(1);

	for(new i = 1; i <= g_perksNum; i++) {
		if(g_plrPerk[i] == perkID) {
			SetClientPerk(i);
		}
	}
}

public int nat_GetClassesNum(Handle plugin, int paramsNum) {
	return g_classesNum;
}

public int nat_GetPerksNum(Handle plugin, int paramsNum) {
	return g_perksNum;
}

public int nat_GetClassID(Handle plugin, int paramsNum) {
	char name[MAX_CLASSNAME_LENGTH + 1];
	
	GetNativeString(1, name, MAX_CLASSNAME_LENGTH);
	return GetClassID(name);
}

int GetClassID(const char[] name) {
	for (int i = 1; i <= g_classesNum; i++) {
		if (StrEqual(name, g_className[i])) {
			return i;
		}
	}
	
	return 0;
}

public int nat_GetPerkID(Handle plugin, int paramsNum) {
	char name[MAX_PERKNAME_LENGTH + 1];
	
	GetNativeString(1, name, MAX_PERKNAME_LENGTH);
	return GetPerkID(name);
}

int GetPerkID(const char[] name) {
	for (int i = 1; i <= g_perksNum; i++) {
		if (StrEqual(name, g_perkName[i])) {
			return i;
		}
	}
	
	return 0;
}

public int nat_GetClassName(Handle plugin, int paramsNum) {
	SetNativeString(2, g_className[GetNativeCell(1)], GetNativeCell(3));
}

public int nat_GetClassDesc(Handle plugin, int paramsNum) {
	SetNativeString(2, g_classDesc[GetNativeCell(1)], GetNativeCell(3));
}

public int nat_GetClassWeapons(Handle plugin, int paramsNum) {
	int classID = GetNativeCell(1);

	SetNativeArray(2, g_classWeapon[classID], MAX_CLASSWEAPONSNUM-1);
	return g_classWeaponsNum[classID];
}

public int nat_GetClassStatsPoints(Handle plugin, int paramsNum) {
	return g_classStats[GetNativeCell(1)][GetNativeCell(2)];
}

public int nat_GetPerkName(Handle plugin, int paramsNum) {
	SetNativeString(2, g_perkName[GetNativeCell(1)], GetNativeCell(3));
}

public int nat_GetPerkDesc(Handle plugin, int paramsNum) {
	SetNativeString(2, g_perkDesc[GetNativeCell(1)], GetNativeCell(3));
}

public int nat_GetPerkMaxValue(Handle plugin, int paramsNum) {
	return g_perkValue[GetNativeCell(1)][1];
}

public int nat_GetPerkMinValue(Handle plugin, int paramsNum) {
	return g_perkValue[GetNativeCell(1)][0];
}

public int nat_GetLevelExp(Handle plugin, int paramsNum) {
	return g_levelExp[GetNativeCell(1)];
}

public int nat_GetClientExp(Handle plugin, int paramsNum) {
	return g_plrExp[GetNativeCell(1)];
}

public int nat_GetClientLevel(Handle plugin, int paramsNum) {
	return g_plrLevel[GetNativeCell(1)];
}

public int nat_GetClientClass(Handle plugin, int paramsNum) {
	return g_plrClass[GetNativeCell(1)];
}

public int nat_GetClientPerk(Handle plugin, int paramsNum) {
	return g_plrPerk[GetNativeCell(1)];
}

public int nat_GetClientPerkValue(Handle plugin, int paramsNum) {
	return g_plrPerkValue[GetNativeCell(1)];
}

public int nat_GetClientStatsPoints(Handle plugin, int paramsNum) {
	return g_plrStatsPoints[GetNativeCell(1)][GetNativeCell(2)];
}

public int nat_GetClientBonusStatsPoints(Handle plugin, int paramsNum) {
	return g_plrBonusStatsPoints[GetNativeCell(1)][GetNativeCell(2)];
}

public int nat_GetClientCoins(Handle plugin, int paramsNum) {
	return g_plrCoins[GetNativeCell(1)];
}

public int nat_GetClientUsableIntelligence(Handle plugin, int paramsNum) {
	return g_plrUsableIntelligence[GetNativeCell(1)];
}

public int nat_SetClientExp(Handle plugin, int paramsNum) {
	int client = GetNativeCell(1);
	
	g_plrExp[client] = GetNativeCell(2);
	CheckExp(client);
}

public int nat_SetClientLevel(Handle plugin, int paramsNum) {
	int client = GetNativeCell(1);
	
	g_plrExp[client] = g_levelExp[GetNativeCell(2) - 1];
	CheckExp(client);
	
	return 1;
}

public int nat_SetClientClass(Handle plugin, int paramsNum) {
	return SetClientClass(GetNativeCell(1), GetNativeCell(2));
}

public int nat_SetClientPerk(Handle plugin, int paramsNum) {
	return SetClientPerk(GetNativeCell(1), GetNativeCell(2), GetNativeCell(3), GetNativeCell(4));
}

public int nat_SetClientStatsPoints(Handle plugin, int paramsNum) {
	g_plrStatsPoints[GetNativeCell(1)][GetNativeCell(2)] = GetNativeCell(3);
}

public int nat_SetClientBonusStatsPoints(Handle plugin, int paramsNum) {
	g_plrBonusStatsPoints[GetNativeCell(1)][GetNativeCell(2)] = GetNativeCell(3);
}

public int nat_SetClientCoins(Handle plugin, int paramsNum) {
	SetClientCoins(GetNativeCell(1), GetNativeCell(2));
}

void SetClientCoins(int client, int value) {
	g_plrCoins[client] = value;
	SetEntData(client, g_accountOffset, value, 4, true);
}

public int nat_GiveClientWeapon(Handle plugin, int paramsNum) {
	int client = GetNativeCell(1);
	CSWeaponID weaponID = view_as<CSWeaponID>(GetNativeCell(2));
	
	g_plrBonusWeapon[client][g_plrBonusWeaponsNum[client]++] = weaponID;

	if (IsClientInGame(client) && IsPlayerAlive(client)) {
		char weaponName[64], weaponAlias[32];

		CS_WeaponIDToAlias(weaponID, weaponAlias, sizeof(weaponAlias));
		Format(weaponName, sizeof(weaponName), "weapon_%s", weaponAlias);

		return GivePlayerItem2(client, weaponName);
	}
	
	return 0;
}

public int nat_TakeClientWeapon(Handle plugin, int paramsNum) {
	int client = GetNativeCell(1), weaponsNum = g_plrBonusWeaponsNum[client];
	CSWeaponID weaponID = view_as<CSWeaponID>(GetNativeCell(2));

	for(int i = 0; i < weaponsNum; i++) {
		if(g_plrBonusWeapon[client][i] == weaponID) {
			for(int j = i+1; j < weaponsNum; j++) {
				g_plrBonusWeapon[j-1] = g_plrBonusWeapon[j];
			}

			weaponsNum = --g_plrBonusWeaponsNum[client];
			break;
		}
	}

	if (IsClientInGame(client) && IsPlayerAlive(client)) {
		for (int i = 0; i <= weaponsNum; i++) {
			if (g_plrBonusWeapon[client][i] == weaponID) {
				return;
			}
		}
		
		int classID = g_plrClass[client];
		for (int i = 0; i < g_classWeaponsNum[classID]; i++) {
			if (g_classWeapon[classID][i] == weaponID) {
				return;
			}
		}

		char weaponName[64], weaponAlias[32];

		CS_WeaponIDToAlias(weaponID, weaponAlias, sizeof(weaponAlias));
		Format(weaponName, sizeof(weaponName), "weapon_%s", weaponAlias);
		
		DropClientWeapon(client, weaponName);
	}
}

public int nat_InflictDamage(Handle plugin, int paramsNum) {
	int client = GetNativeCell(1);
	SDKHooks_TakeDamage(GetNativeCell(3), GetNativeCell(2), client, view_as<float>(GetNativeCell(4)) + (view_as<float>(GetNativeCell(5)) * float(g_plrUsableIntelligence[client])), GetNativeCell(6) | (1 << 31), GetNativeCell(7), NULL_VECTOR, NULL_VECTOR);
}

public int nat_MakeExplosion(Handle plugin, int paramsNum) {
	float explosionPos[3];

	int client = GetNativeCell(1);
	GetNativeArray(2, explosionPos, 3);
	
	int exploEntity = CreateEntityByName("env_explosion");
	g_plrLastExploId[client] = exploEntity;

	if (exploEntity != -1) {
		DispatchKeyValue(exploEntity,"classname","env_explosion");
		
		SetEntProp(exploEntity, Prop_Data, "m_spawnflags", 6146);
		SetEntProp(exploEntity, Prop_Data, "m_iMagnitude", RoundFloat(view_as<float>(GetNativeCell(3)) + (view_as<float>(GetNativeCell(4)) * float(g_plrUsableIntelligence[client]))));
		SetEntProp(exploEntity, Prop_Data, "m_iRadiusOverride", GetNativeCell(5));
		
		DispatchSpawn(exploEntity);
		ActivateEntity(exploEntity);
		
		TeleportEntity(exploEntity, explosionPos, NULL_VECTOR, NULL_VECTOR);
		SetEntPropEnt(exploEntity, Prop_Send, "m_hOwnerEntity", client);
		SetEntProp(exploEntity, Prop_Send, "m_iTeamNum", GetEntProp(client, Prop_Send, "m_iTeamNum"));
		
		EmitSoundToAll("weapons/hegrenade/explode5.wav", exploEntity, 1, 90);
		
		AcceptEntityInput(exploEntity, "Explode");
		AcceptEntityInput(exploEntity, "Kill");
	}
}

public int nat_ClientClassSkillGotReady(Handle plugin, int paramsNum) {
	int client = GetNativeCell(1);

	if(g_plrTimerNextClassSkillUsage[client] != null) {
		KillTimer(g_plrTimerNextClassSkillUsage[client]);
		g_plrTimerNextClassSkillUsage[client] = null;
	}

	float gameTime = GetGameTime();
	float coolDown = view_as<float>(GetNativeCell(2));

	g_plrNextClassSkillUsage[client] = gameTime + coolDown;
	g_plrTimerNextClassSkillUsage[client] = CreateTimer(coolDown, timer_ClassSkillIsReady, client, TIMER_FLAG_NO_MAPCHANGE);
}

public int nat_ClientPerkGotReady(Handle plugin, int paramsNum) {
	int client = GetNativeCell(1);

	if(g_plrTimerNextPerkUsage[client] != null) {
		KillTimer(g_plrTimerNextPerkUsage[client]);
		g_plrTimerNextPerkUsage[client] = null;
	}

	float coolDown = view_as<float>(GetNativeCell(2));

	g_plrNextPerkUsage[client] = GetGameTime() + coolDown;
	g_plrTimerNextPerkUsage[client] = CreateTimer(coolDown, timer_PerkIsReady, client, TIMER_FLAG_NO_MAPCHANGE);
}

public Action timer_ClassSkillIsReady(Handle timer, any client) {
	g_plrTimerNextClassSkillUsage[client] = null;

	if(!IsPlayerAlive(client)) {
		return Plugin_Continue;
	}

	PrintCenterText(client, "Umiejętność klasy gotowa do użycia!");
	EmitSoundToClient(client, "items/battery_pickup.wav", -2, 0, 0, 0, 0.5, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	
	return Plugin_Continue;
}

public Action timer_PerkIsReady(Handle timer, any client) {
	g_plrTimerNextPerkUsage[client] = null;

	if(!IsPlayerAlive(client)) {
		return Plugin_Continue;
	}

	PrintCenterText(client, "Umiejętność perku gotowa do użycia!");
	EmitSoundToClient(client, "items/battery_pickup.wav", -2, 0, 0, 0, 0.5, 100, -1, NULL_VECTOR, NULL_VECTOR, true, 0.0);
	return Plugin_Continue;
}

int SetClientPerk(const int client, const int perkID2 = -1, const int perkValue2 = -1, const bool info = true) {
	int perkID = (perkID2 == -1) ? GetRandomInt(1, g_perksNum) : perkID2;
	int perkValue = (perkValue2 == -1) ? GetRandomInt(g_perkValue[perkID][0], g_perkValue[perkID][1]) : perkValue2;
	Action ret;
	
	Call_StartForward(g_fwPerkChanged);
	Call_PushCell(client);
	Call_PushCell(perkID);
	Call_PushCell(perkValue);
	Call_Finish(ret);
	
	if (perkID == 0) {
		g_plrPerk[client] = 0;
		g_plrPerkValue[client] = 0;
		
		return 0;
	}
	
	if (ret == Plugin_Handled) {
		SetClientPerk(client, -1, -1, info);
		return 0;
	}
	
	g_plrPerk[client] = perkID;
	g_plrPerkValue[client] = perkValue;
	
	if (info) {
		PrintToChat(client, " \x06\x04%s\x01 Otrzymałeś \x06\x05 %s!", g_prefix, g_perkName[perkID]);
	}
	
	Call_StartForward(g_fwPerkChangedPost);
	Call_PushCell(client);
	Call_PushCell(perkID);
	Call_PushCell(perkValue);
	Call_Finish();
	
	return g_plrPerk[client];
}

bool PrepareNewPlayerClass(int client, int classID) {
	if (classID == g_plrClass[client]) {
		return true;
	}
	
	if (!classID) {
		SetClientClass(client, 0);
		return true;
	} else if (!g_plrClass[client] && IsClientInGame(client) && IsPlayerAlive(client)) {
		SetClientClass(client, classID);
		return true;
	}
	
	PrintToChat(client, " \x06\x04%s\x01 Klasa zostanie zmieniona w następnej rundzie.", g_prefix);
	g_plrNewSelectedClass[client] = classID;
	return false;
}

int SetClientClass(int client, int classID) {
	if (g_plrClass[client]) {
		SaveClientClassData(client, g_plrClass[client]);
	}
	
	Action ret;
	Call_StartForward(g_fwClassChanged);
	Call_PushCell(client);
	Call_PushCell(classID);
	Call_Finish(ret);
	
	if (ret == Plugin_Handled) {
		g_plrClass[client] = 0;
		g_plrNewSelectedClass[client] = 0;

		cmd_SelectClass(client, 0);
		return 0;
	}

	g_plrClass[client] = classID;
	g_plrNewSelectedClass[client] = classID;

	if(classID) {
		ReadClassData(client, classID);
	}
	
	return classID;
}

void UpdateClientWeapons(int client) {
	RemoveAllClientWeapons(client);

	int classID = g_plrClass[client];
	char weaponName[64], weaponAlias[32];
	for (int i = 0; i < g_classWeaponsNum[classID]; i++) {
		CS_WeaponIDToAlias(g_classWeapon[classID][i], weaponAlias, sizeof(weaponAlias));
		Format(weaponName, sizeof(weaponName), "weapon_%s", weaponAlias);

		GivePlayerItem2(client, weaponName);
	}
	
	for (int i = 0; i < g_plrBonusWeaponsNum[client]; i++) {
		CS_WeaponIDToAlias(g_plrBonusWeapon[client][i], weaponAlias, sizeof(weaponAlias));
		Format(weaponName, sizeof(weaponName), "weapon_%s", weaponAlias);

		GivePlayerItem2(client, weaponName);
	}
}

void UpdateClientStatsBonuses(int client) {
	int classID = g_plrClass[client];

	g_plrUsableIntelligence[client] = g_plrStatsPoints[client][INT_PTS] + g_classStats[classID][INT_PTS] + g_plrBonusStatsPoints[client][INT_PTS]
	int health = 100 + g_plrStatsPoints[client][HEALTH_PTS] + g_classStats[classID][HEALTH_PTS] + g_plrBonusStatsPoints[client][HEALTH_PTS];
	int stamina = g_plrStatsPoints[client][STAMINA_PTS] + g_classStats[classID][STAMINA_PTS] + g_plrBonusStatsPoints[client][STAMINA_PTS];

	SetEntData(client, FindDataMapInfo(client, "m_iMaxHealth"), health, 4, true);
	SetEntData(client, FindDataMapInfo(client, "m_iHealth"), health, 4, true);

	SetEntProp(client, Prop_Send, "m_ArmorValue", stamina, 1);
	SetEntProp(client, Prop_Send, "m_bHasHelmet", stamina >= 100 ? 1 : 0);
	SetEntPropFloat(client, Prop_Send, "m_flLaggedMovementValue", 1.0 + float(g_plrStatsPoints[client][SPEED_PTS] + g_classStats[classID][SPEED_PTS] + g_plrBonusStatsPoints[client][SPEED_PTS]) * 0.0025);
}

bool ReadPlayerData(int client) {
	char steamID[64];
	
	if (!GetClientAuthId(client, AuthId_Steam2, steamID, sizeof(steamID))) {
		return false;
	}
	
	char query[512];
	Format(query, sizeof(query), "SELECT c.name, e.level, p.coins FROM codd0_players AS p LEFT JOIN codd0_experience AS e ON p.playerID=e.playerID LEFT JOIN codd0_classes AS c ON e.classID=c.classID WHERE p.steamID='%s';", steamID);
	
	g_isPlayerDataLoading[client] = true;
	SQL_TQuery(g_sqlConn, ReadPlayerData_Handler, query, GetClientUserId(client));
	
	return true;
}

public void ReadPlayerData_Handler(Handle sqlConn, Handle result, const char[] error, any userID) {
	if (result == null) {
		LogError("ReadPlayerData_Handler error: %s", error);
		return;
	}

	int client = GetClientOfUserId(userID);
	
	if (!client) {
		return;
	}
	
	int classID;
	char className[MAX_CLASSNAME_LENGTH + 1];
	bool isPlayerInDB;
	
	while (SQL_MoreRows(result) && SQL_FetchRow(result)) {
		SQL_FetchString(result, 0, className, MAX_CLASSNAME_LENGTH);

		if(strlen(className)) {
			classID = GetClassID(className);
			g_plrClassLevel[client][classID] = SQL_FetchInt(result, 1);
		}

		if(!isPlayerInDB) {
			g_plrCoins[client] = SQL_FetchInt(result, 2);
			isPlayerInDB = true;
		}
	}
	
	char steamID[64];
		
	if (!GetClientAuthId(client, AuthId_Steam2, steamID, sizeof(steamID))) {
		return;
	}

	char query[256], name[64], escapedName[192];

	GetClientName(client, name, sizeof(name));
	SQL_EscapeString(g_sqlConn, name, escapedName, sizeof(escapedName));

	if(!isPlayerInDB) {
		Format(query, sizeof(query), "INSERT INTO codd0_players (steamID, name) VALUES ('%s', '%s')", steamID, escapedName);
		SQL_TQuery(g_sqlConn, InsertPlayerToDB_Handler, query, GetClientUserId(client));
	} else {
		g_isPlayerDataLoading[client] = false;
	}
}

public void InsertPlayerToDB_Handler(Handle sqlConn, Handle result, const char[] error, any userID) {
	if (result == null) {
		LogError("InsertPlayerToDB_Handler error: %s", error);
		return;
	}

	int client = GetClientOfUserId(userID);
	
	if (client) {
		g_isPlayerDataLoading[client] = false;
	}
}

bool ReadClassData(int client, int classID) {
	char steamID[64];
	
	if (!GetClientAuthId(client, AuthId_Steam2, steamID, sizeof(steamID))) {
		return false;
	}
	
	char query[512], className[MAX_CLASSNAME_LENGTH*2+1];

	SQL_EscapeString(g_sqlConn, g_className[classID], className, MAX_CLASSNAME_LENGTH*2);
	Format(query, sizeof(query), "SELECT e.experience, e.statIntelligence, e.statHealth, e.statStamina, e.statTrim FROM codd0_experience AS e INNER JOIN codd0_classes AS c ON e.classID=c.classID INNER JOIN codd0_players AS p ON p.playerID=e.playerID WHERE p.steamID='%s' AND c.name='%s';", steamID, className);
	
	g_isPlayerClassDataLoading[client] = true;
	SQL_TQuery(g_sqlConn, ReadClassData_Handler, query, GetClientUserId(client));
	
	return true;
}

public void ReadClassData_Handler(Handle sqlConn, Handle result, const char[] error, any userID) {
	if (result == null) {
		LogError("ReadClassData_Handler error: %s", error);
		return;
	}

	int client = GetClientOfUserId(userID);
	
	if (!client) {
		return;
	}
	
	if (SQL_FetchRow(result)) {
		int pointsSum = 0;
		
		g_plrLevel[client] = g_plrClassLevel[client][g_plrClass[client]];
		g_plrExp[client] = SQL_FetchInt(result, 0);
		
		for (int i = 1; i <= 4; i++) {
			g_plrStatsPoints[client][i] = SQL_FetchInt(result, 0 + i);
			pointsSum += g_plrStatsPoints[client][i];
		}
		
		g_plrStatsPoints[client][0] = g_plrLevel[client] - 1 - pointsSum;
		g_isPlayerClassDataLoading[client] = false;
	} else {
		char steamID[64];
		
		g_plrLevel[client] = 1;
		g_plrExp[client] = 0;
		
		for (new i = 0; i <= 4; i++) {
			g_plrStatsPoints[client][i] = 0;
		}
		
		if (!GetClientAuthId(client, AuthId_Steam2, steamID, sizeof(steamID))) {
			return;
		}

		char query[512], escapedName[MAX_CLASSNAME_LENGTH*2+1];
		
		SQL_EscapeString(g_sqlConn, g_className[g_plrClass[client]], escapedName, MAX_CLASSNAME_LENGTH*2);
		Format(query, sizeof(query), "INSERT INTO codd0_experience (playerID, classID) SELECT playerID, classID FROM codd0_classes AS c INNER JOIN codd0_players AS p WHERE c.name='%s' AND p.steamID='%s'", escapedName, steamID);
		SQL_TQuery(g_sqlConn, InsertPlayerClassToDB_Handler, query, userID);
	}

	int freeExp = g_levelExp[RoundFloat(float(g_top15_level[0]) * GetConVarFloat(g_cvFreeLevelMultiplier))];

	if(freeExp > g_plrExp[client]) {
		g_plrExp[client] = freeExp;
		CheckExp(client);

		PrintToChat(client, " \x06\x04[COD:MW]\x01 Ze względu na brak balansu zwięszyliśmy Twój poziom :)");
	}

	if(IsPlayerAlive(client)) {
		UpdateClientWeapons(client);
		UpdateClientStatsBonuses(client);
	}

	Call_StartForward(g_fwClassChangedPost);
	Call_PushCell(client);
	Call_PushCell(g_plrClass[client]);
	Call_Finish();
}

public void InsertPlayerClassToDB_Handler(Handle sqlConn, Handle result, const char[] error, any userID) {
	if (result == null) {
		LogError("InsertPlayerClassToDB_Handler error: %s", error);
		return;
	}

	int client = GetClientOfUserId(userID);
	
	if (client) {
		g_isPlayerClassDataLoading[client] = false;
	}
}

bool SaveClientData(int client, const bool nonThreaded = false) {
	if(g_isPlayerDataLoading[client]) {
		return false;
	}

	char steamID[64];
	
	if (!GetClientAuthId(client, AuthId_Steam2, steamID, sizeof(steamID))) {
		return false;
	}
	
	char query[512], name[64], escapedName[128];
	GetClientName(client, name, sizeof(name));
	SQL_EscapeString(g_sqlConn, name, escapedName, sizeof(escapedName));
	Format(query, sizeof(query), "UPDATE codd0_players SET coins=%d, name='%s' WHERE steamID='%s';", g_plrCoins[client], escapedName, steamID);

	if(nonThreaded) {
		if(!SQL_FastQuery(g_sqlConn, query)) {
			char error[256];

			SQL_GetError(g_sqlConn, error, sizeof(error));
			LogError("SaveClientData_Handler error: %s", error);
		}
	} else {
		SQL_TQuery(g_sqlConn, SaveClientData_Handler, query);
	}

	return true;
}

public void SaveClientData_Handler(Handle sqlConn, Handle result, const char[] error, any data) {
	if (result == null) {
		LogError("SaveClientData_Handler error: %s", error);
	}
}

void SaveClientClassData(int client, int classID) {
	if(g_isPlayerClassDataLoading[client]) {
		return;
	}

	char steamID[64];
	
	if (!GetClientAuthId(client, AuthId_Steam2, steamID, sizeof(steamID))) {
		return;
	}
	
	char query[512], name[MAX_CLASSNAME_LENGTH*2+1];

	SQL_EscapeString(g_sqlConn, g_className[classID], name, MAX_CLASSNAME_LENGTH*2);
	Format(query, sizeof(query), "UPDATE codd0_experience AS e INNER JOIN codd0_players AS p ON e.playerID=p.playerID INNER JOIN codd0_classes AS c ON e.classID=c.classID SET e.level=%d, e.experience=%d, e.statIntelligence=%d, e.statHealth=%d, e.statStamina=%d, e.statTrim=%d WHERE p.steamID='%s' AND c.name='%s'", 
		g_plrLevel[client], g_plrExp[client], g_plrStatsPoints[client][INT_PTS], g_plrStatsPoints[client][HEALTH_PTS], g_plrStatsPoints[client][STAMINA_PTS], g_plrStatsPoints[client][SPEED_PTS], steamID, name);
	
	SQL_TQuery(g_sqlConn, SaveClientClassData_Handler, query);
}

public void SaveClientClassData_Handler(Handle sqlConn, Handle result, const char[] error, any data) {
	if (result == null) {
		LogError("SaveClientClassData_Handler error: %s", error);
	}
}

void SortClasses() {
	char name[MAX_CLASSESNUM+1][MAX_CLASSNAME_LENGTH+1];

	for(int i = 1; i <= g_classesNum; i++) {
		strcopy(name[i-1], MAX_CLASSNAME_LENGTH, g_className[i]);
	}

	SortStrings(name, g_classesNum, Sort_Ascending);

	for(int i = 1; i <= g_classesNum; i++) {
		g_sortedClassesOrder[i] = GetClassID(name[i-1]);
	}
}


void SortPerks() {
	char name[MAX_CLASSESNUM+1][MAX_PERKNAME_LENGTH+1];

	for(int i = 1; i <= g_perksNum; i++) {
		strcopy(name[i-1], MAX_PERKNAME_LENGTH, g_perkName[i]);
	}

	SortStrings(name, g_perksNum, Sort_Ascending);

	for(int i = 1; i <= g_perksNum; i++) {
		g_sortedPerksOrder[i] = GetPerkID(name[i-1]);
	}
}

stock int GivePlayerItem2(int client, const char[] weaponName) {
	int entity;

	g_canTakeWeapons[client] = true;
	entity = GivePlayerItem(client, weaponName);
	g_canTakeWeapons[client] = false;

	return entity;
}


stock bool DropClientWeapon(int client, const char[] weaponName) {
	int entity =  FindEntityByClassname(-1, weaponName);
	
	while(entity > 0) {
		if(client == GetEntPropEnt(entity, Prop_Send, "m_hOwnerEntity")) {
			RemovePlayerItem(client, entity);
			AcceptEntityInput(entity, "kill");
			
			return true;
		}
		
		entity =  FindEntityByClassname(entity, weaponName);
	}
	
	return false;
}

stock void RemoveAllClientWeapons(int client) {
	int entity;

	for(int i = 0; i < 4; i++) {
		if(i == CS_SLOT_KNIFE) {
			continue;
		}

		while((entity = GetPlayerWeaponSlot(client, i)) > 0) {
			RemovePlayerItem(client, entity);
			AcceptEntityInput(entity, "kill");
		}
	}
}

int GetLowerValue(int val1, int val2) {
	if(val1 > val2) {
		return val2;
	}

	return val1;
}

CSWeaponID GetWeaponID(int weaponEnt) {
	CSWeaponID weaponId = CS_ItemDefIndexToID(GetEntProp(weaponEnt, Prop_Send, "m_iItemDefinitionIndex"));

	if(weaponId > CSWeapon_MAX_WEAPONS_NO_KNIFES || weaponId == CSWeapon_KNIFE_GG || weaponId == CSWeapon_KNIFE_T || weaponId == CSWeapon_KNIFE_GHOST) {
		return CSWeapon_KNIFE;
	}

	return weaponId;
}